<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿振的博客</title>
  
  <subtitle>空间信息处理技术分享站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://theonegis.github.io/"/>
  <updated>2020-06-13T15:41:58.507Z</updated>
  <id>http://theonegis.github.io/</id>
  
  <author>
    <name>阿振</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shapefile属性操作之查</title>
    <link href="http://theonegis.github.io/geos/Shapefile%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%E4%B9%8B%E6%9F%A5/"/>
    <id>http://theonegis.github.io/geos/Shapefile属性操作之查/</id>
    <published>2020-06-13T15:14:28.000Z</published>
    <updated>2020-06-13T15:41:58.507Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>作者：阿振</p><p>写作时间：2020-06-13 夜</p><hr><h1 id="开篇">开篇</h1><p>在前面几篇博文中，我们分别介绍了矢量空间数据的属性数据的增（CREATE）删（DELETE）改（UPDATE）操作，这篇博文我们来聊聊属性数据的查询（Retrieve）操作。</p><h1 id="案例介绍">案例介绍</h1><p>我们还是使用之前的分省Shapefile数据，主要包含每个省的一些统计信息。下面以两个案例进行介绍：</p><ol type="1"><li>从给定数据中查询中学数量（HighSchool字段）大于1万所的省份</li><li>从给定数据中查询中学数量最多的省份</li></ol><p>下面简单说一下使用GDAL进行属性数据查询的两种思路：</p><ol type="1"><li>因为矢量数据的属性一般都是以关系表进行保存的，所以我们可以使用关系数据库查询语言SQL进行数据查询。GDAL支持部分SQL查询功能。</li><li>我们可以遍历图层Layer中包含的所有Feature要素，然后读取要素的属性数据进行筛选过滤得到我们想要的结果。</li></ol><h1 id="sql查询方式">SQL查询方式</h1><h2 id="代码展示">代码展示</h2><p>Talk is cheap. Show me the code.</p><p>首先，我们来看看使用SQL进行查询的代码。</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">from</span> osgeo <span class="im">import</span> ogr</span><span id="cb1-2"><a href="#cb1-2"></a>ogr.UseExceptions()</span><span id="cb1-3"><a href="#cb1-3"></a></span><span id="cb1-4"><a href="#cb1-4"></a>ds: ogr.DataSource <span class="op">=</span> ogr.Open(<span class="st">&#39;../data/Provinces.shp&#39;</span>)</span><span id="cb1-5"><a href="#cb1-5"></a><span class="co"># 注意Layer的名称不能包含中文</span></span><span id="cb1-6"><a href="#cb1-6"></a>layer: ogr.Layer <span class="op">=</span> ds.GetLayer()</span><span id="cb1-7"><a href="#cb1-7"></a><span class="co"># 选择出中学数量大于1万所的省份</span></span><span id="cb1-8"><a href="#cb1-8"></a>query: <span class="bu">str</span> <span class="op">=</span> <span class="ss">f&#39;SELECT NAME, HighSchool FROM </span><span class="sc">{</span>layer<span class="sc">.</span>GetName()<span class="sc">}</span><span class="ss"> WHERE HighSchool &gt; 10000&#39;</span></span><span id="cb1-9"><a href="#cb1-9"></a>selected: ogr.Layer <span class="op">=</span> ds.ExecuteSQL(query)</span><span id="cb1-10"><a href="#cb1-10"></a><span class="co"># 这里的Feature中只包含两个属性NAME和HighSchool</span></span><span id="cb1-11"><a href="#cb1-11"></a><span class="cf">for</span> feature <span class="kw">in</span> selected:</span><span id="cb1-12"><a href="#cb1-12"></a>    <span class="bu">print</span>(feature.GetField(<span class="st">&#39;NAME&#39;</span>))</span><span id="cb1-13"><a href="#cb1-13"></a></span><span id="cb1-14"><a href="#cb1-14"></a><span class="co"># 选择出中学数量最多的省份</span></span><span id="cb1-15"><a href="#cb1-15"></a><span class="co"># 我尝试使用MAX函数和嵌套的SELECT语句进行实现，但是执行报错，应该是OGR不支持嵌套的SQL查询</span></span><span id="cb1-16"><a href="#cb1-16"></a>query: <span class="bu">str</span> <span class="op">=</span> <span class="ss">f&#39;SELECT NAME, HighSchool FROM </span><span class="sc">{</span>layer<span class="sc">.</span>GetName()<span class="sc">}</span><span class="ss"> ORDER BY HighSchool DESC&#39;</span></span><span id="cb1-17"><a href="#cb1-17"></a>selected: ogr.Layer <span class="op">=</span> ds.ExecuteSQL(query)</span><span id="cb1-18"><a href="#cb1-18"></a><span class="bu">print</span>(selected.GetFeature(<span class="dv">0</span>).GetField(<span class="st">&#39;NAME&#39;</span>))</span><span id="cb1-19"><a href="#cb1-19"></a><span class="bu">print</span>(selected.GetFeature(<span class="dv">0</span>).GetField(<span class="st">&#39;HighSchool&#39;</span>))</span><span id="cb1-20"><a href="#cb1-20"></a></span><span id="cb1-21"><a href="#cb1-21"></a><span class="kw">del</span> ds</span></code></pre></div><h2 id="方法总结">方法总结</h2><ol type="1"><li>首先我们使用<code>ogr.Open()</code>函数读取数据，使用<code>GetLayer()</code>方法获取图层</li><li>然后构造SQL查询语句，图层名称对应的是SQL语句中的表名。注意如果图层名称为中文，查询会失败。</li><li>然后使用<code>ExecuteSQL()</code>方法执行查询，得到的查询结果仍然是一个<code>ogr.Layer</code>图层类，但是图层中的要素属性只包含我们查询语句中指定的字段</li><li>对于第二个案例，我们本来可以使用一个嵌套的SELECT查询语句以及MAX聚合函数得到最大的中学数量，但是使用嵌套的SQL查询执行会失败。所以我在第二个案例中使用了ORDER BY子句进行排序，然后查询结果的第一个要素就是我们寻找的最大值。</li></ol><h1 id="遍历feature要素方式">遍历Feature要素方式</h1><h2 id="代码展示-1">代码展示</h2><p>我们再来看使用遍历Feature要素的方法。</p><div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">from</span> osgeo <span class="im">import</span> ogr</span><span id="cb2-2"><a href="#cb2-2"></a>ogr.UseExceptions()</span><span id="cb2-3"><a href="#cb2-3"></a></span><span id="cb2-4"><a href="#cb2-4"></a>ds: ogr.DataSource <span class="op">=</span> ogr.Open(<span class="st">&#39;../data/Provinces.shp&#39;</span>)</span><span id="cb2-5"><a href="#cb2-5"></a><span class="co"># 注意Layer的名称不能包含中文</span></span><span id="cb2-6"><a href="#cb2-6"></a>layer: ogr.Layer <span class="op">=</span> ds.GetLayer()</span><span id="cb2-7"><a href="#cb2-7"></a><span class="co"># 使用filter函数对要素属性进行过滤</span></span><span id="cb2-8"><a href="#cb2-8"></a>selected <span class="op">=</span> <span class="bu">list</span>(<span class="bu">filter</span>(<span class="kw">lambda</span> f: f.GetField(<span class="st">&#39;HighSchool&#39;</span>) <span class="op">&gt;</span> <span class="dv">10000</span>, layer))</span><span id="cb2-9"><a href="#cb2-9"></a><span class="cf">for</span> feature <span class="kw">in</span> selected:</span><span id="cb2-10"><a href="#cb2-10"></a>    <span class="bu">print</span>(feature.GetField(<span class="st">&#39;NAME&#39;</span>))</span><span id="cb2-11"><a href="#cb2-11"></a></span><span id="cb2-12"><a href="#cb2-12"></a><span class="co"># 使用sorted方法对要素进行自定义排序，这里使用逆序</span></span><span id="cb2-13"><a href="#cb2-13"></a>selected <span class="op">=</span> <span class="bu">sorted</span>(layer, key<span class="op">=</span><span class="kw">lambda</span> f: f.GetField(<span class="st">&#39;HighSchool&#39;</span>), reverse<span class="op">=</span><span class="va">True</span>)</span><span id="cb2-14"><a href="#cb2-14"></a><span class="bu">print</span>(selected[<span class="dv">0</span>].GetField(<span class="st">&#39;NAME&#39;</span>))</span><span id="cb2-15"><a href="#cb2-15"></a><span class="bu">print</span>(selected[<span class="dv">0</span>].GetField(<span class="st">&#39;HighSchool&#39;</span>))</span><span id="cb2-16"><a href="#cb2-16"></a></span><span id="cb2-17"><a href="#cb2-17"></a><span class="kw">del</span> ds</span></code></pre></div><h2 id="方法总结-1">方法总结</h2><ol type="1"><li>使用遍历Feature要素的方法进行查询是我们在获取了图层包含的所有Feature要素集合以后，使用Python内置的函数对该集合进行过滤，排序等操作得到我们想要的查询结果。</li><li><code>filter()</code>函数的第一个参数是一个自定义函数，第二个参数是一个可迭代对象iterable。该函数会遍历可迭代对象将满足第一个自定义函数的值过滤出来。</li><li><code>sorted()</code>函数包含三个参数（后两个可选），第一个参数是一个可迭代对象iterable，第二个参数是用于自定义排序的函数，第三个参数指定是否逆序。<code>sorted()</code>函数的返回值是一个<code>list</code>对象。</li><li>我更喜欢使用第二种遍历的方式，因为更方便调试一些。当然如果对SQL语言熟悉的同学，可能更喜欢SQL这种声明式编程的方式。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;作者：阿振&lt;/p&gt;
&lt;p&gt;写作时间：2020-06-13 夜&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;开篇&quot;&gt;开篇&lt;/h1&gt;
&lt;p&gt;在前面几篇博文中，我们分别介绍了矢量空间数据的属性数据的增（CREATE）删（DE
      
    
    </summary>
    
      <category term="空间数据处理" scheme="http://theonegis.github.io/categories/geos/"/>
    
    
      <category term="Shapefile" scheme="http://theonegis.github.io/tags/Shapefile/"/>
    
      <category term="GDAL" scheme="http://theonegis.github.io/tags/GDAL/"/>
    
      <category term="矢量数据" scheme="http://theonegis.github.io/tags/%E7%9F%A2%E9%87%8F%E6%95%B0%E6%8D%AE/"/>
    
      <category term="属性操作" scheme="http://theonegis.github.io/tags/%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C/"/>
    
      <category term="增加字段" scheme="http://theonegis.github.io/tags/%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>Shapefile属性操作之改</title>
    <link href="http://theonegis.github.io/geos/Shapefile%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%E4%B9%8B%E6%94%B9/"/>
    <id>http://theonegis.github.io/geos/Shapefile属性操作之改/</id>
    <published>2020-06-13T09:37:06.000Z</published>
    <updated>2020-06-13T09:48:53.956Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>作者：阿振</p><p>写作时间：2020-06-13</p><hr><h1 id="开篇">开篇</h1><p>在上篇的《<a href="https://theonegis.blog.csdn.net/article/details/106735196" target="_blank" rel="noopener">Shapfile属性操作之增</a>》和《<a href="https://blog.csdn.net/theonegis/article/details/106735451" target="_blank" rel="noopener">Shapefile属性操作之删</a>》中我们分别介绍了对于空间矢量数据属性的增加（CREATE）和删除（DELETE）操作，这篇我们聊聊数据的更新操作（UPDATE）。</p><h1 id="案例介绍">案例介绍</h1><p>这里我们要处理的数据是中国地图分省的矢量Shapefile，是一个面状数据。该数据有一个<code>NAME</code>字段，给出了每个省的名称。这里我们要更新<code>NAME</code>字段，给直辖市名称后面添加“市”字，给自治区后面添加“自治区”字样，给特别行政区后面添加“特别行政区”字样，剩下的省名称后面添加“省”字。</p><p>思路是我们遍历图层中的每一个Feature要素，然后通过<code>ogr.Feature</code>的<code>SetField()</code>方法更新属性值。</p><h1 id="代码展示">代码展示</h1><p>Talk is cheap. Show me the code.</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">from</span> osgeo <span class="im">import</span> ogr</span><span id="cb1-2"><a href="#cb1-2"></a>ogr.UseExceptions()</span><span id="cb1-3"><a href="#cb1-3"></a></span><span id="cb1-4"><a href="#cb1-4"></a></span><span id="cb1-5"><a href="#cb1-5"></a><span class="co"># 打开一个Shapefile</span></span><span id="cb1-6"><a href="#cb1-6"></a>ds: ogr.DataSource <span class="op">=</span> ogr.Open(<span class="st">&#39;../data/省级行政区.shp&#39;</span>, update<span class="op">=</span><span class="va">True</span>)</span><span id="cb1-7"><a href="#cb1-7"></a>layer: ogr.Layer <span class="op">=</span> ds.GetLayer()</span><span id="cb1-8"><a href="#cb1-8"></a></span><span id="cb1-9"><a href="#cb1-9"></a><span class="co"># 填充属性值</span></span><span id="cb1-10"><a href="#cb1-10"></a><span class="cf">for</span> feature <span class="kw">in</span> layer:</span><span id="cb1-11"><a href="#cb1-11"></a>    name: <span class="bu">str</span> <span class="op">=</span> feature.GetField(<span class="st">&#39;NAME&#39;</span>)</span><span id="cb1-12"><a href="#cb1-12"></a>    <span class="cf">if</span> name <span class="kw">in</span> (<span class="st">&#39;北京&#39;</span>, <span class="st">&#39;天津&#39;</span>, <span class="st">&#39;重庆&#39;</span>, <span class="st">&#39;上海&#39;</span>):</span><span id="cb1-13"><a href="#cb1-13"></a>        name <span class="op">+=</span> <span class="st">&#39;市&#39;</span></span><span id="cb1-14"><a href="#cb1-14"></a>    <span class="cf">elif</span> name <span class="kw">in</span> (<span class="st">&#39;内蒙古&#39;</span>, <span class="st">&#39;广西&#39;</span>, <span class="st">&#39;宁夏&#39;</span>, <span class="st">&#39;新疆&#39;</span>, <span class="st">&#39;西藏&#39;</span>):</span><span id="cb1-15"><a href="#cb1-15"></a>        name <span class="op">+=</span> <span class="st">&#39;自治区&#39;</span></span><span id="cb1-16"><a href="#cb1-16"></a>    <span class="cf">elif</span> name <span class="kw">in</span> (<span class="st">&#39;香港&#39;</span>, <span class="st">&#39;澳门&#39;</span>):</span><span id="cb1-17"><a href="#cb1-17"></a>        name <span class="op">+=</span> <span class="st">&#39;特别行政区&#39;</span></span><span id="cb1-18"><a href="#cb1-18"></a>    <span class="cf">else</span>:</span><span id="cb1-19"><a href="#cb1-19"></a>        name <span class="op">+=</span> <span class="st">&#39;省&#39;</span></span><span id="cb1-20"><a href="#cb1-20"></a>    feature.SetField(<span class="st">&#39;NAME&#39;</span>, name)</span><span id="cb1-21"><a href="#cb1-21"></a>    <span class="co"># 修改完了记得Set一下</span></span><span id="cb1-22"><a href="#cb1-22"></a>    layer.SetFeature(feature)</span><span id="cb1-23"><a href="#cb1-23"></a></span><span id="cb1-24"><a href="#cb1-24"></a><span class="co"># 关闭数据集</span></span><span id="cb1-25"><a href="#cb1-25"></a>ds <span class="op">=</span> <span class="va">None</span></span></code></pre></div><h1 id="方法总结">方法总结</h1><ol type="1"><li>首先，我们使用<code>ogr.Open()</code>函数打开Shapefile数据，注意我们要设置<code>update</code>参数为<code>True</code>，即允许GDAL更新我们的原始数据。</li><li>使用<code>GetLayer()</code>方法获取图层，然后使用for循环遍历图层中的要素。通过<code>GetField()</code>方法获取需要修改的字段，然后通过<code>SetField()</code>方法修改字段。</li><li>记得添加完属性值以后，需要使用<code>SetFeature()</code>方法将当前<code>feature</code>更新到涂层<code>layer</code>中去。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;作者：阿振&lt;/p&gt;
&lt;p&gt;写作时间：2020-06-13&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;开篇&quot;&gt;开篇&lt;/h1&gt;
&lt;p&gt;在上篇的《&lt;a href=&quot;https://theonegis.blog.csdn.n
      
    
    </summary>
    
      <category term="空间数据处理" scheme="http://theonegis.github.io/categories/geos/"/>
    
    
      <category term="Shapefile" scheme="http://theonegis.github.io/tags/Shapefile/"/>
    
      <category term="GDAL" scheme="http://theonegis.github.io/tags/GDAL/"/>
    
      <category term="矢量数据" scheme="http://theonegis.github.io/tags/%E7%9F%A2%E9%87%8F%E6%95%B0%E6%8D%AE/"/>
    
      <category term="属性操作" scheme="http://theonegis.github.io/tags/%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C/"/>
    
      <category term="增加字段" scheme="http://theonegis.github.io/tags/%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>Shapefile属性操作之删</title>
    <link href="http://theonegis.github.io/geos/Shapefile%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%88%A0/"/>
    <id>http://theonegis.github.io/geos/Shapefile属性操作之删/</id>
    <published>2020-06-13T08:53:05.000Z</published>
    <updated>2020-06-13T09:56:47.326Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>作者：阿振</p><p>写作时间：2020-06-13 又是一个周末</p><hr><h1 id="开篇">开篇</h1><p>延续上篇的《<a href="https://theonegis.blog.csdn.net/article/details/106735196" target="_blank" rel="noopener">Shapfile属性操作之增</a>》，这篇我们来聊聊如何进行属性删除。使用的工具依旧是我们的GDAL库。</p><h1 id="案例介绍">案例介绍</h1><p>这里我们要处理的数据是中国地图分省的矢量Shapefile，是一个面状数据。在上篇中我们给该数据添加了一个属性字段<code>Abbr</code>用以表示省的简称。这篇我们再把该字段给删除掉。</p><p>删除的方法包括两部：首先，从属性表中找到该字段，然后删除该字段。</p><h1 id="代码展示">代码展示</h1><p>Talk is cheap. Show me the code.</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">from</span> osgeo <span class="im">import</span> ogr</span><span id="cb1-2"><a href="#cb1-2"></a>ogr.UseExceptions()</span><span id="cb1-3"><a href="#cb1-3"></a></span><span id="cb1-4"><a href="#cb1-4"></a></span><span id="cb1-5"><a href="#cb1-5"></a><span class="co"># 从给定图层中读取字段的定义，根据给定字段名称找到该字段的索引编号</span></span><span id="cb1-6"><a href="#cb1-6"></a><span class="kw">def</span> get_field_index_by_name(layer: ogr.Layer, name: <span class="bu">str</span>):</span><span id="cb1-7"><a href="#cb1-7"></a>    defs: ogr.FeatureDefn <span class="op">=</span> layer.GetLayerDefn()</span><span id="cb1-8"><a href="#cb1-8"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(defs.GetFieldCount()):</span><span id="cb1-9"><a href="#cb1-9"></a>        <span class="cf">if</span> name <span class="op">==</span> defs.GetFieldDefn(i).GetName():</span><span id="cb1-10"><a href="#cb1-10"></a>            <span class="cf">return</span> i</span><span id="cb1-11"><a href="#cb1-11"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&#39;</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss"> not found&#39;</span>)</span><span id="cb1-12"><a href="#cb1-12"></a></span><span id="cb1-13"><a href="#cb1-13"></a></span><span id="cb1-14"><a href="#cb1-14"></a><span class="co"># 打开一个Shapefile文件</span></span><span id="cb1-15"><a href="#cb1-15"></a>ds: ogr.DataSource <span class="op">=</span> ogr.Open(<span class="st">&#39;../data/省级行政区.shp&#39;</span>, update<span class="op">=</span><span class="va">True</span>)</span><span id="cb1-16"><a href="#cb1-16"></a>layer: ogr.Layer <span class="op">=</span> ds.GetLayer()</span><span id="cb1-17"><a href="#cb1-17"></a><span class="co"># 删除Abbr字段</span></span><span id="cb1-18"><a href="#cb1-18"></a>index <span class="op">=</span> get_field_index_by_name(layer, <span class="st">&#39;Abbr_1&#39;</span>)</span><span id="cb1-19"><a href="#cb1-19"></a>layer.DeleteField(index)</span><span id="cb1-20"><a href="#cb1-20"></a>ds <span class="op">=</span> <span class="va">None</span></span></code></pre></div><h1 id="方法总结">方法总结</h1><ol type="1"><li>GDAL的图层<code>ogr.Layer</code>类提供了<code>DeleteField()</code>方法用于删除字段，但是该方法传入的参数必须是要删除字段的索引编号。</li><li>我们一般的业务需求是根据字段名称去进行删除操作，所以我自定义了一个<code>get_field_index_by_name()</code>函数用于从给定图层中查找给定字段名称对应的索引编号。该函数接受两个参数，第一个是图层变量，第二个是字段名称。该函数实现的逻辑是遍历传入的图层中的字段的定义，找到和给定名称相同的字段并返回其索引。有一种特殊情况是传入的字段名称在当前图层中并不存在，对于这种情况，我们直接抛出一个<code>ValueError</code>错误。</li><li>这样我们就可以采用<code>layer</code>的<code>DeleteField()</code>方法进行删除了。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;作者：阿振&lt;/p&gt;
&lt;p&gt;写作时间：2020-06-13 又是一个周末&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;开篇&quot;&gt;开篇&lt;/h1&gt;
&lt;p&gt;延续上篇的《&lt;a href=&quot;https://theonegis.blo
      
    
    </summary>
    
      <category term="空间数据处理" scheme="http://theonegis.github.io/categories/geos/"/>
    
    
      <category term="Shapefile" scheme="http://theonegis.github.io/tags/Shapefile/"/>
    
      <category term="GDAL" scheme="http://theonegis.github.io/tags/GDAL/"/>
    
      <category term="矢量数据" scheme="http://theonegis.github.io/tags/%E7%9F%A2%E9%87%8F%E6%95%B0%E6%8D%AE/"/>
    
      <category term="属性操作" scheme="http://theonegis.github.io/tags/%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C/"/>
    
      <category term="增加字段" scheme="http://theonegis.github.io/tags/%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>Shapefile属性操作之增</title>
    <link href="http://theonegis.github.io/geos/Shapefile%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%A2%9E/"/>
    <id>http://theonegis.github.io/geos/Shapefile属性操作之增/</id>
    <published>2020-06-13T08:52:05.000Z</published>
    <updated>2020-06-13T09:16:17.866Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>作者：阿振</p><p>写作时间：2020-06-13 又是一个周末</p><hr><h1 id="开篇">开篇</h1><p>《<a href="https://blog.csdn.net/theonegis/article/details/80089375" target="_blank" rel="noopener">Python空间数据处理实战</a>》系列的博文好久都没有更新了，今天乘周末有点时间，补了个觉，然后写几篇博文。</p><p>关于Python空间数据处理，如果大家有什么想看到的内容，欢迎评论区留言，我会增加一些大家需要的内容！</p><p>今天我打算用四篇博客简要介绍一下如何对空间矢量数据的属性数据进行操作。对于属性数据，我们可以简单将其看作一个二维表格，学过数据库的朋友，可能会想到关系数据库的概念。是的，我们现在的空间矢量数据的属性数据大部分就是以关系表的形式进行存储的。而对于关系数据库的操作，常用的就是增删改查（CRUD，即Create，Retrieve，Update，Delete）操作。</p><p>这篇博文单讲Create增加操作，使用的工具还是我们的GDAL库。</p><h1 id="案例介绍">案例介绍</h1><p>我还是喜欢用案例的方式进行知识的讲解。这里我们要处理的数据是中国地图分省的矢量Shapefile，是一个面状数据。该数据有一个<code>NAME</code>字段，给出了每个省的名称。然后我们需要给给数据增加一个属性字段<code>Abbr</code>，用以表示每个省的简称。</p><p>要完成这项工作，我们首先需要建立一个省份名称到简称的字典，方便程序查询。然后读取原始数据，新建一个属性字段<code>Abbr</code>，然后遍历数据中的每个Feature要素，取出<code>NAME</code>，再根据字典查询到当前<code>NAME</code>对应的<code>Abbr</code>填充进对应的字段即可。</p><h1 id="代码展示">代码展示</h1><p>Talk is cheap. Show me the code.</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">from</span> osgeo <span class="im">import</span> ogr</span><span id="cb1-2"><a href="#cb1-2"></a>ogr.UseExceptions()</span><span id="cb1-3"><a href="#cb1-3"></a></span><span id="cb1-4"><a href="#cb1-4"></a></span><span id="cb1-5"><a href="#cb1-5"></a><span class="co"># 首先定义每个省全称到简称的映射字典</span></span><span id="cb1-6"><a href="#cb1-6"></a>names <span class="op">=</span> {</span><span id="cb1-7"><a href="#cb1-7"></a>    <span class="st">&#39;北京&#39;</span>: <span class="st">&#39;京&#39;</span>,</span><span id="cb1-8"><a href="#cb1-8"></a>    <span class="st">&#39;天津&#39;</span>: <span class="st">&#39;津&#39;</span>,</span><span id="cb1-9"><a href="#cb1-9"></a>    <span class="st">&#39;重庆&#39;</span>: <span class="st">&#39;渝&#39;</span>,</span><span id="cb1-10"><a href="#cb1-10"></a>    <span class="st">&#39;上海&#39;</span>: <span class="st">&#39;沪&#39;</span>,</span><span id="cb1-11"><a href="#cb1-11"></a>    <span class="st">&#39;河北&#39;</span>: <span class="st">&#39;冀&#39;</span>,</span><span id="cb1-12"><a href="#cb1-12"></a>    <span class="st">&#39;山西&#39;</span>: <span class="st">&#39;晋&#39;</span>,</span><span id="cb1-13"><a href="#cb1-13"></a>    <span class="st">&#39;辽宁&#39;</span>: <span class="st">&#39;辽&#39;</span>,</span><span id="cb1-14"><a href="#cb1-14"></a>    <span class="st">&#39;吉林&#39;</span>: <span class="st">&#39;吉&#39;</span>,</span><span id="cb1-15"><a href="#cb1-15"></a>    <span class="st">&#39;黑龙江&#39;</span>: <span class="st">&#39;黑&#39;</span>,</span><span id="cb1-16"><a href="#cb1-16"></a>    <span class="st">&#39;江苏&#39;</span>: <span class="st">&#39;苏&#39;</span>,</span><span id="cb1-17"><a href="#cb1-17"></a>    <span class="st">&#39;浙江&#39;</span>: <span class="st">&#39;浙&#39;</span>,</span><span id="cb1-18"><a href="#cb1-18"></a>    <span class="st">&#39;安徽&#39;</span>: <span class="st">&#39;皖&#39;</span>,</span><span id="cb1-19"><a href="#cb1-19"></a>    <span class="st">&#39;福建&#39;</span>: <span class="st">&#39;闽&#39;</span>,</span><span id="cb1-20"><a href="#cb1-20"></a>    <span class="st">&#39;江西&#39;</span>: <span class="st">&#39;赣&#39;</span>,</span><span id="cb1-21"><a href="#cb1-21"></a>    <span class="st">&#39;山东&#39;</span>: <span class="st">&#39;鲁&#39;</span>,</span><span id="cb1-22"><a href="#cb1-22"></a>    <span class="st">&#39;河南&#39;</span>: <span class="st">&#39;豫&#39;</span>,</span><span id="cb1-23"><a href="#cb1-23"></a>    <span class="st">&#39;湖北&#39;</span>: <span class="st">&#39;鄂&#39;</span>,</span><span id="cb1-24"><a href="#cb1-24"></a>    <span class="st">&#39;湖南&#39;</span>: <span class="st">&#39;湘&#39;</span>,</span><span id="cb1-25"><a href="#cb1-25"></a>    <span class="st">&#39;广东&#39;</span>: <span class="st">&#39;粤&#39;</span>,</span><span id="cb1-26"><a href="#cb1-26"></a>    <span class="st">&#39;海南&#39;</span>: <span class="st">&#39;琼&#39;</span>,</span><span id="cb1-27"><a href="#cb1-27"></a>    <span class="st">&#39;四川&#39;</span>: <span class="st">&#39;川/蜀&#39;</span>,</span><span id="cb1-28"><a href="#cb1-28"></a>    <span class="st">&#39;贵州&#39;</span>: <span class="st">&#39;黔/贵&#39;</span>,</span><span id="cb1-29"><a href="#cb1-29"></a>    <span class="st">&#39;云南&#39;</span>: <span class="st">&#39;云/滇&#39;</span>,</span><span id="cb1-30"><a href="#cb1-30"></a>    <span class="st">&#39;陕西&#39;</span>: <span class="st">&#39;陕/秦&#39;</span>,</span><span id="cb1-31"><a href="#cb1-31"></a>    <span class="st">&#39;甘肃&#39;</span>: <span class="st">&#39;甘/陇&#39;</span>,</span><span id="cb1-32"><a href="#cb1-32"></a>    <span class="st">&#39;青海&#39;</span>: <span class="st">&#39;青&#39;</span>,</span><span id="cb1-33"><a href="#cb1-33"></a>    <span class="st">&#39;台湾&#39;</span>: <span class="st">&#39;台&#39;</span>,</span><span id="cb1-34"><a href="#cb1-34"></a>    <span class="st">&#39;内蒙古&#39;</span>: <span class="st">&#39;蒙&#39;</span>,</span><span id="cb1-35"><a href="#cb1-35"></a>    <span class="st">&#39;广西&#39;</span>: <span class="st">&#39;桂&#39;</span>,</span><span id="cb1-36"><a href="#cb1-36"></a>    <span class="st">&#39;宁夏&#39;</span>: <span class="st">&#39;宁&#39;</span>,</span><span id="cb1-37"><a href="#cb1-37"></a>    <span class="st">&#39;新疆&#39;</span>: <span class="st">&#39;新&#39;</span>,</span><span id="cb1-38"><a href="#cb1-38"></a>    <span class="st">&#39;西藏&#39;</span>: <span class="st">&#39;藏&#39;</span>,</span><span id="cb1-39"><a href="#cb1-39"></a>    <span class="st">&#39;香港&#39;</span>: <span class="st">&#39;港&#39;</span>,</span><span id="cb1-40"><a href="#cb1-40"></a>    <span class="st">&#39;澳门&#39;</span>: <span class="st">&#39;澳&#39;</span></span><span id="cb1-41"><a href="#cb1-41"></a>}</span><span id="cb1-42"><a href="#cb1-42"></a></span><span id="cb1-43"><a href="#cb1-43"></a><span class="co"># 打开一个Shapefile文件获取属性定义</span></span><span id="cb1-44"><a href="#cb1-44"></a>ds: ogr.DataSource <span class="op">=</span> ogr.Open(<span class="st">&#39;../data/省级行政区.shp&#39;</span>, update<span class="op">=</span><span class="va">True</span>)</span><span id="cb1-45"><a href="#cb1-45"></a>layer: ogr.Layer <span class="op">=</span> ds.GetLayer()</span><span id="cb1-46"><a href="#cb1-46"></a>defs: ogr.FeatureDefn <span class="op">=</span> layer.GetLayerDefn()</span><span id="cb1-47"><a href="#cb1-47"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(defs.GetFieldCount()):</span><span id="cb1-48"><a href="#cb1-48"></a>    defn: ogr.FieldDefn <span class="op">=</span> defs.GetFieldDefn(i)</span><span id="cb1-49"><a href="#cb1-49"></a>    <span class="bu">print</span>(<span class="ss">f&#39;</span><span class="sc">{</span>defn<span class="sc">.</span>GetName()<span class="sc">}</span><span class="ss"> -&gt;  </span><span class="sc">{</span>defn<span class="sc">.</span>GetType()<span class="sc">}</span><span class="ss"> -&gt; </span><span class="sc">{</span>defn<span class="sc">.</span>GetWidth()<span class="sc">}</span><span class="ss">&#39;</span>)</span><span id="cb1-50"><a href="#cb1-50"></a></span><span id="cb1-51"><a href="#cb1-51"></a><span class="co"># 添加一个省简称的字段</span></span><span id="cb1-52"><a href="#cb1-52"></a>field: ogr.FieldDefn <span class="op">=</span> ogr.FieldDefn(<span class="st">&#39;Abbr&#39;</span>, ogr.OFTString)</span><span id="cb1-53"><a href="#cb1-53"></a>field.SetWidth(<span class="dv">5</span>)</span><span id="cb1-54"><a href="#cb1-54"></a>layer.CreateField(field)</span><span id="cb1-55"><a href="#cb1-55"></a></span><span id="cb1-56"><a href="#cb1-56"></a><span class="co"># 填充属性值</span></span><span id="cb1-57"><a href="#cb1-57"></a><span class="cf">for</span> feature <span class="kw">in</span> layer:</span><span id="cb1-58"><a href="#cb1-58"></a>    name: <span class="bu">str</span> <span class="op">=</span> feature.GetField(<span class="st">&#39;NAME&#39;</span>)</span><span id="cb1-59"><a href="#cb1-59"></a>    feature.SetField(<span class="st">&#39;Abbr&#39;</span>, names.get(name, <span class="st">&#39;&#39;</span>))</span><span id="cb1-60"><a href="#cb1-60"></a>    <span class="co"># 修改完了记得Set一下</span></span><span id="cb1-61"><a href="#cb1-61"></a>    layer.SetFeature(feature)</span><span id="cb1-62"><a href="#cb1-62"></a></span><span id="cb1-63"><a href="#cb1-63"></a><span class="co"># 关闭数据集</span></span><span id="cb1-64"><a href="#cb1-64"></a>ds <span class="op">=</span> <span class="va">None</span></span></code></pre></div><h1 id="方法总结">方法总结</h1><p>下面我们来对上面的代码进行一个方法的总结：</p><ol type="1"><li>首先，我们使用<code>ogr.Open()</code>函数打开Shapefile数据，注意我们要设置<code>update</code>参数为<code>True</code>，即允许GDAL更新我们的原始数据。</li><li>使用<code>ogr.FieldDefn()</code>函数新建一个字段，然后添加到<code>layer</code>图层中。注意我们这里新建的字段的类型是字符串类型<code>ogr.OFTString</code>，当然我们还可以新建其他类型的字段，例如整形<code>ogr.OFTInteger</code>，实数形<code>ogr.OFTReal</code>，日期型<code>ogr.OFTDate</code>等。一般对于字符串类型，我们还需要设置字符串的宽度。</li><li>接下来我们遍历<code>layer</code>中的<code>feature</code>，使用<code>SetField()</code>方法设置属性值。记得添加完属性值以后，需要使用<code>SetFeature()</code>方法将当前<code>feature</code>更新到涂层<code>layer</code>中去。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;作者：阿振&lt;/p&gt;
&lt;p&gt;写作时间：2020-06-13 又是一个周末&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;开篇&quot;&gt;开篇&lt;/h1&gt;
&lt;p&gt;《&lt;a href=&quot;https://blog.csdn.net/theo
      
    
    </summary>
    
      <category term="空间数据处理" scheme="http://theonegis.github.io/categories/geos/"/>
    
    
      <category term="Shapefile" scheme="http://theonegis.github.io/tags/Shapefile/"/>
    
      <category term="GDAL" scheme="http://theonegis.github.io/tags/GDAL/"/>
    
      <category term="矢量数据" scheme="http://theonegis.github.io/tags/%E7%9F%A2%E9%87%8F%E6%95%B0%E6%8D%AE/"/>
    
      <category term="属性操作" scheme="http://theonegis.github.io/tags/%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C/"/>
    
      <category term="增加字段" scheme="http://theonegis.github.io/tags/%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>QGIS制图中面积小的区域不显示注记</title>
    <link href="http://theonegis.github.io/geos/QGIS%E5%88%B6%E5%9B%BE%E4%B8%AD%E9%9D%A2%E7%A7%AF%E5%B0%8F%E7%9A%84%E5%8C%BA%E5%9F%9F%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%B3%A8%E8%AE%B0/"/>
    <id>http://theonegis.github.io/geos/QGIS制图中面积小的区域不显示注记/</id>
    <published>2020-05-23T23:32:38.000Z</published>
    <updated>2020-05-24T00:18:12.129Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>作者：阿振</p><p>写作时间：2020-05-24 周天</p><hr><h1 id="qgis制图中面积太小的区域不显示注记">QGIS制图中面积太小的区域不显示注记</h1><p>在使用QGIS进行制图的过程中，对于面积太小的区域有可能存在注记显示不出来的情况。比如在中国地图中，香港和澳门区域面积较小，就存在显示不了注记的情况。</p><p>如下图，就会发现澳门没有显示出来。</p><figure><img src="/images/QGIS/屏幕快照%202020-05-24%20上午7.36.07.png" alt=""><figcaption>屏幕快照 2020-05-24 上午7.36.07</figcaption></figure><p>这时候，我们需要进行一些额外的设置，右键相应的图层，选择属性，在注记选项卡中进行设置（<code>Show all labels for this layer</code>），如下图。</p><figure><img src="/images/QGIS/屏幕快照%202020-05-24%20上午7.36.30.png" alt=""><figcaption>屏幕快照 2020-05-24 上午7.36.30</figcaption></figure><p>设置完成以后应该就可以显示了，但是有时候仍然不能正确显示，我们还需要进行如下设置（<code>whole polygon</code>）：</p><figure><img src="/images/QGIS/屏幕快照%202020-05-24%20上午7.37.18.png" alt=""><figcaption>屏幕快照 2020-05-24 上午7.37.18</figcaption></figure><p>最终结果可能存在标签注记压盖的情况，这时候我们可以手动对标签的位置进行调整，达到视觉上清晰的状态。</p><figure><img src="/images/QGIS/屏幕快照%202020-05-24%20上午7.38.47.png" alt=""><figcaption>屏幕快照 2020-05-24 上午7.38.47</figcaption></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;作者：阿振&lt;/p&gt;
&lt;p&gt;写作时间：2020-05-24 周天&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;qgis制图中面积太小的区域不显示注记&quot;&gt;QGIS制图中面积太小的区域不显示注记&lt;/h1&gt;
&lt;p&gt;在使用QGI
      
    
    </summary>
    
      <category term="空间数据处理" scheme="http://theonegis.github.io/categories/geos/"/>
    
    
      <category term="QGIS" scheme="http://theonegis.github.io/tags/QGIS/"/>
    
      <category term="制图" scheme="http://theonegis.github.io/tags/%E5%88%B6%E5%9B%BE/"/>
    
      <category term="技巧" scheme="http://theonegis.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>QGIS面数据融合以后有小的线段或者洞存在如何解决</title>
    <link href="http://theonegis.github.io/geos/QGIS%E9%9D%A2%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%E4%BB%A5%E5%90%8E%E6%9C%89%E5%B0%8F%E7%9A%84%E7%BA%BF%E6%AE%B5%E6%88%96%E8%80%85%E6%B4%9E%E5%AD%98%E5%9C%A8%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"/>
    <id>http://theonegis.github.io/geos/QGIS面数据融合以后有小的线段或者洞存在如何解决/</id>
    <published>2020-05-23T23:09:42.000Z</published>
    <updated>2020-05-24T00:24:12.750Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>作者：阿振</p><p>写作时间：2020-05-24 周末</p><hr><h1 id="qgis面数据融合以后有小的线段或者洞存在如何解决">QGIS面数据融合以后有小的线段或者洞存在如何解决</h1><p>在QGIS中我们使用<code>Dissolve</code>工具进行面数据的融合，如下图对中国分省的矢量面数据进行融合得到国界</p><figure><img src="/images/QGIS/屏幕快照2020-05-24上午7.15.23.png" alt=""><figcaption>屏幕快照2020-05-24上午7.15.23</figcaption></figure><figure><img src="/images/QGIS/屏幕快照2020-05-24%20上午7.13.58.png" alt=""><figcaption>屏幕快照2020-05-24 上午7.13.58</figcaption></figure><figure><img src="/images/QGIS/屏幕快照2020-05-24上午7.15.57.png" alt=""><figcaption>屏幕快照2020-05-24上午7.15.57</figcaption></figure><p>可以看到融合结果中存在明显的细小线段存在，那么融合处理这些问题呢？</p><p>我们可以使用QGIS提供的<code>Delete holes</code>工具进行处理（从菜单栏Processing -&gt; Toolbox进行打开，然后根据名称搜索相关工具）</p><figure><img src="/images/QGIS/屏幕快照2020-05-24上午7.18.08.png" alt=""><figcaption>屏幕快照2020-05-24上午7.18.08</figcaption></figure><p>下面是处理以后的结果图，可以看到讨厌的线段被清除了。</p><figure><img src="/images/QGIS/屏幕快照2020-05-24上午7.19.12.png" alt=""><figcaption>屏幕快照2020-05-24上午7.19.12</figcaption></figure><p>总结一下，QGIS面数据融合的步骤是首先使用<code>Dissolve</code>工具进行面融合，然后使用<code>Delete holes</code>工具进行离散的线段或者小洞的删除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;作者：阿振&lt;/p&gt;
&lt;p&gt;写作时间：2020-05-24 周末&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;qgis面数据融合以后有小的线段或者洞存在如何解决&quot;&gt;QGIS面数据融合以后有小的线段或者洞存在如何解决&lt;/h
      
    
    </summary>
    
      <category term="空间数据处理" scheme="http://theonegis.github.io/categories/geos/"/>
    
    
      <category term="QGIS" scheme="http://theonegis.github.io/tags/QGIS/"/>
    
      <category term="制图" scheme="http://theonegis.github.io/tags/%E5%88%B6%E5%9B%BE/"/>
    
      <category term="技巧" scheme="http://theonegis.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Scala和Kotlin脚本编程</title>
    <link href="http://theonegis.github.io/java/Scala%E5%92%8CKotlin%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"/>
    <id>http://theonegis.github.io/java/Scala和Kotlin脚本编程/</id>
    <published>2020-05-05T10:37:15.000Z</published>
    <updated>2020-05-05T12:17:58.438Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>作者：阿振</p><p>写作时间：2020-05-05 五一假期末</p><hr><h1 id="scala和kotlin脚本编程">Scala和Kotlin脚本编程</h1><p>Scala和Kotlin作为运行在JVM上的编程语言，解决了Java的很多痛点。今天我们来聊聊如何将Scala和Kotlin作为脚本语言使用（Java不支持以脚本形式运行哦）。</p><h2 id="kotlin脚本编程">Kotlin脚本编程</h2><p>Kotlin脚本的扩展名为<code>kts</code>，运行命令为<code>kotlinc -script &lt;脚本文件名.kts&gt;</code></p><h3 id="helloworld示例">HelloWorld示例</h3><p>下面我们来看一个HelloWorld示例：</p><p>新建名称为<code>Main.kts</code>的Kotlin脚本文件，内容如下：</p><div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb1-1"><a href="#cb1-1"></a>println(<span class="st">&quot;你好 ${if (args.isNotEmpty()) args[0] else &quot;&quot;}!&quot;</span>)</span></code></pre></div><p>可以看到脚本程序不需要主函数，Kotlin脚本以<code>args</code>参数接收用户输入（args是一个<code>Array&lt;String&gt;</code>类型的数组）</p><p>在命令行执行：<code>kotlinc -script Main.kts 高寒</code></p><p>得到脚本运行结果为：<code>你好 高寒!</code></p><h3 id="调用外部命令">调用外部命令</h3><p>如果我们想在Kotlin脚本中调用外部的命令或者程序需要怎么做呢？</p><p>使用Java API中提供的<code>Runtime.getRuntime().exec()</code>函数或者<code>ProcessBuilder</code>类创建一个<code>Process</code>对象调用外部命令。</p><p>下面以调用系统<code>ls</code>命令作为示例程序进行演示说明。</p><div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">import</span> <span class="im">java.lang.Runtime</span></span><span id="cb2-2"><a href="#cb2-2"></a></span><span id="cb2-3"><a href="#cb2-3"></a><span class="kw">val</span> <span class="va">process</span>: Process = Runtime.getRuntime().exec(<span class="st">&quot;ls /Users/TheOneGIS/Desktop&quot;</span>)</span><span id="cb2-4"><a href="#cb2-4"></a>process.waitFor()</span><span id="cb2-5"><a href="#cb2-5"></a></span><span id="cb2-6"><a href="#cb2-6"></a>process.inputStream.reader().use {</span><span id="cb2-7"><a href="#cb2-7"></a>    println(it.readText())</span><span id="cb2-8"><a href="#cb2-8"></a>}</span></code></pre></div><p>或者</p><div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">import</span> <span class="im">java.lang.ProcessBuilder</span></span><span id="cb3-2"><a href="#cb3-2"></a></span><span id="cb3-3"><a href="#cb3-3"></a><span class="kw">val</span> <span class="va">process</span>: Process = ProcessBuilder(<span class="st">&quot;ls&quot;</span>, <span class="st">&quot;/Users/TheOneGIS/Desktop&quot;</span>).start()</span><span id="cb3-4"><a href="#cb3-4"></a>process.waitFor()</span><span id="cb3-5"><a href="#cb3-5"></a></span><span id="cb3-6"><a href="#cb3-6"></a>process.inputStream.reader().use {</span><span id="cb3-7"><a href="#cb3-7"></a>    println(it.readText())</span><span id="cb3-8"><a href="#cb3-8"></a>}</span></code></pre></div><p>在命令行中执行<code>kotlinc -script Main.kts</code>，输出结果如下：</p><div class="sourceCode" id="cb4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb4-1"><a href="#cb4-1"></a><span class="dv">11</span></span><span id="cb4-2"><a href="#cb4-2"></a><span class="kw">data</span></span><span id="cb4-3"><a href="#cb4-3"></a>raw</span><span id="cb4-4"><a href="#cb4-4"></a>[这里有一个空行]</span></code></pre></div><p>注意：</p><ol type="1"><li><code>Runtime.getRuntime().exec()</code>函数中直接输入命令名称加参数组成的字符串</li><li><code>ProcessBuilder</code>使用多个参数进行命令名称和参数进行类的初始化</li><li>命令中的路径名称不能使用<code>~</code>特殊字符，否则会出错。建议使用全路径。</li><li><code>Process.waitFor()</code>等待调用的外部程序执行完毕再接着执行脚本后续代码。</li><li>从输出结果的InputStream中得到文本输出，可以看到最终的文本输出每一行之后都会增加一个换行符。</li></ol><h2 id="scala脚本编程">Scala脚本编程</h2><p>Scala脚本的扩展名仍为<code>scala</code>，运行命令为<code>scala &lt;脚本文件名.scala&gt;</code>，和普通的Scala类一样。</p><h3 id="helloworld示例-1">HelloWorld示例</h3><p>新建名称为<code>Main.scala</code>的Scala脚本文件，内容如下：</p><div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1"></a><span class="fu">println</span>(s<span class="st">&quot;你好 ${if (args.nonEmpty) args(0) else &quot;&quot;}!&quot;</span>)</span></code></pre></div><p>可以看到和Kotlin脚本程序一样不需要主函数，Scala脚本同样以<code>args</code>参数接收用户输入（args是一个<code>Array[String]</code>类型的数组）</p><p>在命令行执行：<code>scala Main.scala 高寒</code></p><p>得到脚本运行结果为：<code>你好 高寒!</code></p><h3 id="调用外部命令-1">调用外部命令</h3><p>在Scala中可以调用Java方法，我们可以直接使用上面类似Kotlin的方式，但是Scala中为我们提供了更加便捷的方法来调用外部命令或程序，下面我们来看一下吧！</p><ol type="1"><li>使用<code>Process</code>的<code>!</code>方法，得到执行结果的状态码，一般0表示成功</li><li>使用<code>Process</code>的<code>!!</code>方法，得到执行结果的文本输出</li><li>使用<code>Process</code>的<code>lazyLines</code>方法，将得到保存在<code>LazyList[String]</code>结构的输出中（延迟执行）</li></ol><p>注意：这里的<code>Process</code>类是Scala类库中提供的，前面在Kotlin中使用的<code>Process</code>类是Java类库中提供的。</p><p>我们先来看第一种方式：</p><div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">import</span> sys.<span class="fu">process</span>._</span><span id="cb6-2"><a href="#cb6-2"></a>Process(<span class="st">&quot;ls /Users/TheOneGIS/Desktop&quot;</span>).!</span></code></pre></div><p>在命令行中运行<code>scala Main.scala</code>，得到执行结果：</p><div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1"></a><span class="dv">11</span></span><span id="cb7-2"><a href="#cb7-2"></a>data</span><span id="cb7-3"><a href="#cb7-3"></a>raw</span></code></pre></div><p><code>Process</code>的<code>!</code>方法是有返回值的，这里我们直接舍弃了，并不关心<code>ls</code>的返回值，我们只关心<code>ls</code>命令的输出结果。</p><p>再看第二种方式：</p><div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">import</span> sys.<span class="fu">process</span>._</span><span id="cb8-2"><a href="#cb8-2"></a><span class="kw">val</span> results = Process(<span class="st">&quot;ls /Users/TheOneGIS/Desktop&quot;</span>).!!</span><span id="cb8-3"><a href="#cb8-3"></a><span class="fu">println</span>(results)</span></code></pre></div><p>在命令行中运行<code>scala Main.scala</code>，得到执行结果：</p><div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1"></a><span class="dv">11</span></span><span id="cb9-2"><a href="#cb9-2"></a>data</span><span id="cb9-3"><a href="#cb9-3"></a>raw</span><span id="cb9-4"><a href="#cb9-4"></a>[这里有一个空行]</span></code></pre></div><p>可以看到<code>results</code>字符串是给<code>ls</code>命令的每个输出字符后面都加了换行符。</p><p>再看第三种方式：</p><div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">import</span> sys.<span class="fu">process</span>._</span><span id="cb10-2"><a href="#cb10-2"></a><span class="kw">val</span> results = Process(<span class="st">&quot;ls /Users/TheOneGIS/Desktop&quot;</span>).<span class="fu">lazyLines</span></span><span id="cb10-3"><a href="#cb10-3"></a>results.<span class="fu">foreach</span>(println)</span></code></pre></div><p>输出结果和第一种方式一样，不过当需要获取最后输出并且需要对输出进行操作的时候我最喜欢使用第三种方式，不需要对输出进行进一步处理的时候我喜欢使用第一种方式。</p><h2 id="scala和kotlin脚本编程的异同">Scala和Kotlin脚本编程的异同</h2><ol type="1"><li>Scala脚本的扩展名和执行方式和普通Scala类一样；Kotlin脚本的扩展名为<code>kts</code>，执行的时候需要加<code>-script</code>参数</li><li>Scala提供了对于外部命令调用的快捷方法；Kotlin主要依靠Java类库进行外部命令调用</li><li>在IntelliJ IDEA中可以直接运行Kotlin脚本，但是不支持直接运行Scala脚本</li><li>IntelliJ IDEA提供了对<a href="https://ammonite.io" target="_blank" rel="noopener">Ammonite</a>项目的支持，可以运行Ammonite Scala脚本</li></ol><p>注：Ammonite项目扩展了Scala的脚本功能，添加了很多额外的特性，甚至提供了一个基于Scala的Shell（类似于Bash Shell）。用Ammonite写的Scala脚本扩展名为<code>sc</code>，使用<code>amm</code>命令进行执行。感兴趣的童鞋可以去围观该项目。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;作者：阿振&lt;/p&gt;
&lt;p&gt;写作时间：2020-05-05 五一假期末&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;scala和kotlin脚本编程&quot;&gt;Scala和Kotlin脚本编程&lt;/h1&gt;
&lt;p&gt;Scala和Kot
      
    
    </summary>
    
      <category term="Java" scheme="http://theonegis.github.io/categories/java/"/>
    
    
      <category term="Scala" scheme="http://theonegis.github.io/tags/Scala/"/>
    
      <category term="Kotlin" scheme="http://theonegis.github.io/tags/Kotlin/"/>
    
      <category term="Script" scheme="http://theonegis.github.io/tags/Script/"/>
    
  </entry>
  
  <entry>
    <title>SNAP Java API处理Sentinel-1数据</title>
    <link href="http://theonegis.github.io/geos/SNAP-Java-API%E5%A4%84%E7%90%86Sentinel-1%E6%95%B0%E6%8D%AE/"/>
    <id>http://theonegis.github.io/geos/SNAP-Java-API处理Sentinel-1数据/</id>
    <published>2020-04-13T23:52:26.000Z</published>
    <updated>2020-04-14T01:55:29.716Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>写作时间：2020年4月14日 周二</p><hr><h1 id="使用snap-java-api处理sentinel-1数据">使用SNAP JAVA API处理Sentinel-1数据</h1><p>SNAP软件使用Java语言开发，提供了Python接口snappy，官方教程中也多以Python接口进行示范。但是我在使用Python接口过程中，发现并不是很好用，你必须要同时懂Java语言才能很好地使用Python接口，在IDEA中使用Python接口的代码基本上没有提示，报错了也是Java的错误提示。而且，Java本来是运行在虚拟机上的语言，效率不高，再用Python包一层，更加降低了运行效率。</p><p>所以，对于我来说，SNAP的Python接口就是鸡肋，没有使用的必要。直接使用Java接口，方便程序直接进行调试，有问题可以直接去看源代码，解决了官方资料不足的问题。</p><h2 id="snap-gpf的使用范式">SNAP GPF的使用范式</h2><p>SNAP推荐使用GPF（Graph Processing Framework）进行数据处理。GPF的使用也很简单，首先基于Operation创建Product，然后写入Product。在写入过程中会自动执行Operation完成你想要的数据处理流程，处理的算法是封装在Operation中的。</p><p>使用GPF的好处是你可以进行多个Operation的流程处理，前一个处理结果直接进入后一个处理，不需要写入磁盘，可以减少磁盘IO带来的时间消耗。</p><h2 id="对sentinel-1-grd数据的处理案例">对Sentinel-1 GRD数据的处理案例</h2><p>下面以对Sentinel-1 GRD数据进行一系列预处理流程演示SNAP Java接口的使用。</p><p>预处理的流程包括：首先对GRD各个极化波进行段辐射校正输出后向散射系数（Sigma nought），然后进行数据裁剪，最后进行地形校正的。</p><p>下面是使用Better Java （Kotlin）进行entinel-1 GRD数据处理的源码。其中，<code>GPF.createProduct</code>方法需要传入Operation的名称和参数，这些信息都可以通过查看Java源代码的方式找到。</p><p>代码运行过程中需要下载DEM数据，可能会比较耗时。如果不对数据裁剪，由于原始数据太大，可能会造成内存溢出。我的笔记本根本跑不动。</p><div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">package</span> <span class="im">cn.demo</span></span><span id="cb1-2"><a href="#cb1-2"></a></span><span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span> <span class="im">java.nio.file.Paths</span></span><span id="cb1-4"><a href="#cb1-4"></a><span class="kw">import</span> <span class="im">org.apache.commons.io.FilenameUtils</span></span><span id="cb1-5"><a href="#cb1-5"></a></span><span id="cb1-6"><a href="#cb1-6"></a><span class="kw">import</span> <span class="im">kotlin.collections.HashMap</span></span><span id="cb1-7"><a href="#cb1-7"></a></span><span id="cb1-8"><a href="#cb1-8"></a><span class="kw">import</span> <span class="im">org.esa.snap.core.dataio.ProductIO</span></span><span id="cb1-9"><a href="#cb1-9"></a><span class="kw">import</span> <span class="im">org.esa.snap.core.gpf.GPF</span></span><span id="cb1-10"><a href="#cb1-10"></a><span class="kw">import</span> <span class="im">com.bc.ceres.core.PrintWriterConciseProgressMonitor</span></span><span id="cb1-11"><a href="#cb1-11"></a></span><span id="cb1-12"><a href="#cb1-12"></a><span class="kw">import</span> <span class="im">org.locationtech.jts.io.WKTReader</span></span><span id="cb1-13"><a href="#cb1-13"></a></span><span id="cb1-14"><a href="#cb1-14"></a></span><span id="cb1-15"><a href="#cb1-15"></a><span class="kw">fun</span> <span class="fu">main</span>() {</span><span id="cb1-16"><a href="#cb1-16"></a>    <span class="kw">val</span> <span class="va">srcPath</span> =</span><span id="cb1-17"><a href="#cb1-17"></a>    Paths.<span class="kw">get</span>(<span class="st">&quot;/Users/Demo/Desktop/S1A_IW_GRDH_1SDV_20200301T104455_20200301T104520_031481_03A00B_0A9F.zip&quot;</span>)</span><span id="cb1-18"><a href="#cb1-18"></a>    <span class="kw">val</span> <span class="va">srcProduct</span> = ProductIO.readProduct(srcPath.toFile())</span><span id="cb1-19"><a href="#cb1-19"></a></span><span id="cb1-20"><a href="#cb1-20"></a>    <span class="kw">val</span> <span class="va">outDir</span> = <span class="st">&quot;/Users/Demo/Desktop&quot;</span></span><span id="cb1-21"><a href="#cb1-21"></a>    <span class="kw">val</span> <span class="va">baseName</span> = FilenameUtils.getBaseName(srcPath.toString())</span><span id="cb1-22"><a href="#cb1-22"></a>    GPF.getDefaultInstance().operatorSpiRegistry.loadOperatorSpis()</span><span id="cb1-23"><a href="#cb1-23"></a>    <span class="cf">for</span> (polar <span class="kw">in</span> arrayOf(<span class="st">&quot;VV&quot;</span>, <span class="st">&quot;VH&quot;</span>)) {</span><span id="cb1-24"><a href="#cb1-24"></a>        <span class="co">// 首先进行辐射校正（CALIBRATION）</span></span><span id="cb1-25"><a href="#cb1-25"></a>        <span class="co">// 对应是的org.esa.s1tbx.calibration.gpf.CalibrationOp类</span></span><span id="cb1-26"><a href="#cb1-26"></a>        <span class="kw">var</span> <span class="va">parameters</span> = HashMap&lt;<span class="kw">String</span>, Any&gt;()</span><span id="cb1-27"><a href="#cb1-27"></a>        parameters[<span class="st">&quot;outputSigmaBand&quot;</span>] = <span class="kw">true</span></span><span id="cb1-28"><a href="#cb1-28"></a>        parameters[<span class="st">&quot;selectedPolarisations&quot;</span>] = polar</span><span id="cb1-29"><a href="#cb1-29"></a>        <span class="kw">val</span> <span class="va">caliProduct</span> = GPF.createProduct(<span class="st">&quot;Calibration&quot;</span>, parameters, srcProduct)</span><span id="cb1-30"><a href="#cb1-30"></a></span><span id="cb1-31"><a href="#cb1-31"></a>        <span class="co">// 然后进行裁剪，如果不裁剪，图像太大，容易OutOfMemory</span></span><span id="cb1-32"><a href="#cb1-32"></a>        <span class="co">// 对应的是org.esa.snap.core.gpf.common.SubsetOp类</span></span><span id="cb1-33"><a href="#cb1-33"></a>        <span class="kw">val</span> <span class="va">wktRect</span> = <span class="st">&quot;POLYGON((108.175 33.873,108.782 33.873,108.782 33.129,108.175 33.129,108.175 33.873))&quot;</span></span><span id="cb1-34"><a href="#cb1-34"></a>        parameters[<span class="st">&quot;geoRegion&quot;</span>] = WKTReader().read(wktRect)</span><span id="cb1-35"><a href="#cb1-35"></a>        parameters[<span class="st">&quot;bandNames&quot;</span>] = <span class="st">&quot;Sigma0_${polar}&quot;</span></span><span id="cb1-36"><a href="#cb1-36"></a>        <span class="kw">val</span> <span class="va">subsetProduct</span> = GPF.createProduct(<span class="st">&quot;Subset&quot;</span>, parameters, caliProduct)</span><span id="cb1-37"><a href="#cb1-37"></a></span><span id="cb1-38"><a href="#cb1-38"></a></span><span id="cb1-39"><a href="#cb1-39"></a>        <span class="co">// 然后进行地形校正（TERRAIN CORRECTION）</span></span><span id="cb1-40"><a href="#cb1-40"></a>        <span class="co">// 对应的是org.esa.s1tbx.sar.gpf.geometric.RangeDopplerGeocodingOp</span></span><span id="cb1-41"><a href="#cb1-41"></a>        <span class="kw">val</span> <span class="va">corrPath</span> = <span class="st">&quot;${outDir}/${baseName}_Corrected_${polar}&quot;</span></span><span id="cb1-42"><a href="#cb1-42"></a>        parameters.clear()</span><span id="cb1-43"><a href="#cb1-43"></a>        parameters[<span class="st">&quot;pixelSpacingInMeter&quot;</span>] = <span class="fl">10.0</span></span><span id="cb1-44"><a href="#cb1-44"></a>        parameters[<span class="st">&quot;sourceBands&quot;</span>] = <span class="st">&quot;Sigma0_${polar}&quot;</span></span><span id="cb1-45"><a href="#cb1-45"></a>        <span class="kw">val</span> <span class="va">corrProduct</span> = GPF.createProduct(<span class="st">&quot;Terrain-Correction&quot;</span>, parameters, subsetProduct)</span><span id="cb1-46"><a href="#cb1-46"></a>        ProductIO.writeProduct(</span><span id="cb1-47"><a href="#cb1-47"></a>            corrProduct, corrPath, <span class="st">&quot;GeoTIFF&quot;</span>,</span><span id="cb1-48"><a href="#cb1-48"></a>            PrintWriterConciseProgressMonitor(System.<span class="kw">out</span>)</span><span id="cb1-49"><a href="#cb1-49"></a>        )</span><span id="cb1-50"><a href="#cb1-50"></a>                </span><span id="cb1-51"><a href="#cb1-51"></a>        <span class="co">// 最后进行对象销毁，释放内存空间</span></span><span id="cb1-52"><a href="#cb1-52"></a>        caliProduct.dispose()</span><span id="cb1-53"><a href="#cb1-53"></a>        subsetProduct.dispose()</span><span id="cb1-54"><a href="#cb1-54"></a>        corrProduct.dispose()</span><span id="cb1-55"><a href="#cb1-55"></a>    }</span><span id="cb1-56"><a href="#cb1-56"></a>    srcProduct.dispose()</span><span id="cb1-57"><a href="#cb1-57"></a>}</span></code></pre></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;写作时间：2020年4月14日 周二&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;使用snap-java-api处理sentinel-1数据&quot;&gt;使用SNAP JAVA API处理Sentinel-1数据&lt;/h1&gt;
&lt;p
      
    
    </summary>
    
      <category term="空间数据处理" scheme="http://theonegis.github.io/categories/geos/"/>
    
    
      <category term="Sentinel" scheme="http://theonegis.github.io/tags/Sentinel/"/>
    
      <category term="Java" scheme="http://theonegis.github.io/tags/Java/"/>
    
      <category term="SNAP" scheme="http://theonegis.github.io/tags/SNAP/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel数据处理工具包SNAP Python开发环境搭建</title>
    <link href="http://theonegis.github.io/geos/Sentinel%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E5%8C%85SNAP-Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://theonegis.github.io/geos/Sentinel数据处理工具包SNAP-Python开发环境搭建/</id>
    <published>2020-04-12T02:50:44.000Z</published>
    <updated>2020-04-12T03:39:57.330Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>写作时间：2020年12月4日周末</p><hr><h1 id="sentinel数据处理工具包snap-python开发环境搭建">Sentinel数据处理工具包SNAP Python开发环境搭建</h1><p>这篇博文主要探索安装SNAP工具包并且使用Python接口进行开发过程中搭建开发环境所踩的坑。不得不说欧空局SANP官方提供的资料太少，而且不全面。当然有问题你可以去Forum提问，可是回不回答就是另外一回事了！</p><p>下面言归正传说说如何搭建SNAP Python开发环境用于处理Sentinel卫星数据吧！（这篇文章主要谈开发环境搭建，具体数据处理可以关注后续博文。）</p><p>安装思路是：首先从<a href="https://step.esa.int/main/download/snap-download/" target="_blank" rel="noopener">SNAP</a>官网安装提供的二进制包（截至目前最新版本是7.0.0），然后再进行相应的配置即可。对于二进制包的安装没什么可说的，可是环境的配置到处是坑，按照官网的<a href="https://senbox.atlassian.net/wiki/spaces/SNAP/pages/24051781/Using+SNAP+in+your+Python+programs" target="_blank" rel="noopener">教程</a>根本不可能走通的。</p><p>下面主要谈一下具体如何处理这些问题。</p><h2 id="安装问题">安装问题</h2><p>官网提供了两种形式的Python环境配置（参见<a href="https://senbox.atlassian.net/wiki/spaces/SNAP/pages/50855941/Configure+Python+to+use+the+SNAP-Python+snappy+interface" target="_blank" rel="noopener">Configure Python to use the SNAP-Python (snappy) interface</a>）：第一，在安装二进制包过程中可以选择Python安装目录，SANP安装包自动帮你设置；第二，安装好以后，自己手动进行设置。</p><p>我刚开始是选择第二种方式进行的，第二种方式需要手动编译安装Python接口，但是我从来没有编译成功过。（错误提示：<code>AttributeError: ‘list’ object has no attribute ‘join’</code>，然而根本不知道该怎么解决，<a href="https://forum.step.esa.int/t/opening-img-disk-image-file-in-python/18388/10" target="_blank" rel="noopener">论坛</a>中也有人遇到这样的错误）</p><p>所以我就删掉了装好的SNAP包，重新安装。在安装过程中选择自己提前安装好的Python路径。我是使用Conda提前安装了一个3.6版本的Python环境（<code>conda create -n snap python=3.6</code>）。在安装SNAP过程中根据安装向导进行设置即可。</p><p>注意：SNAP安装过程中安装向导提示要求Python是2.7，3.3或者3.4版本（官方教程中说是支持2.7，3.3或者3.6版本，不知道哪个是对的）。</p><p>安装即算完成了。然后根据官方的教程进行测试，首先切换目录到SNAP Python接口snappy所在目录，macOS下在<code>~/.snap/snap-python</code>，不同操作系统在用户目录下的<code>.snap</code>文件夹中找即可。然后在控制台调用我们刚才安装SNAP过程中设置的Python命令。如果我们是使用Conda安装的Python，直接<code>conda activate snap</code>即可。</p><pre class="shell"><code>cd &lt;cd &lt;snappy-dir&gt;&lt;python-exe&gt;</code></pre><p>在<code>snap-python</code>目录，我们可以使用如下代码进行测试Python开发接口是否正常工作。</p><div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">from</span> snappy <span class="im">import</span> ProductIO</span><span id="cb2-2"><a href="#cb2-2"></a>p <span class="op">=</span> ProductIO.readProduct(<span class="st">&#39;snappy/testdata/MER_FRS_L1B_SUBSET.dim&#39;</span>)</span><span id="cb2-3"><a href="#cb2-3"></a><span class="bu">list</span>(p.getBandNames())</span></code></pre></div><p>然而，测试过程中你会发现有很多问题，而官方教程中根本没提供解决方案。下面细细说一下我遇到的问题以及解决方案。</p><h2 id="缺包问题">缺包问题</h2><p>运行以后的错误提示如下：<code>ImportError: No module named jpyutil</code>，这显然是Python找不到包的缘故。那没有的话，我们安装一个即可（需要安装JPY包，一个用于Java和Python语言直接相互调用的桥接库）。</p><p>安装过程中，我直接使用<code>pip install jpy</code>进行安装，结果又有新的错误。</p><p>后来，我发现<a href="https://github.com/bcdev/jpy/releases" target="_blank" rel="noopener">JPY</a>的GitHub网站上提供了编译好的二进制安装包，根据自己的的平台和Python版本选择合适的WHL二进制文件下载，下载以后直接使用<code>pip install &lt;jpy.whl&gt;</code>命令安装即可（<code>jpy.whl</code>换成你自己下载好的文件路径）。</p><h2 id="jdk版本问题">JDK版本问题</h2><p>缺包问题解决以后，继续进行测试，结果提示找不到JDK的动态链接库，根据错误提示，我发现snappy查找的Python版本跟我系统设置的<code>JAVA_HOME</code>路径中的JDK不一致。可能程序中使用了自己定义好JDK版本(1.8.0_112)，而没有选择使用环境变量中提供的版本。</p><p>所以我根据错误提示我下载了1.8.0_112版本的JDK二进制包进行安装，JDK的问题就算解决了。</p><p>Java JDK官方网站提供的一般是最新的版本，要下载老旧的JDK可以通过网站<a href="https://www.oracle.com/java/technologies/oracle-java-archive-downloads.html" target="_blank" rel="noopener">Oracle Java Archive</a>选择自己的操作系统平台进行二进制包的下载安装，不要忘了提前申请一个Oracle的账号。</p><h2 id="环境变量问题">环境变量问题</h2><p>JDK版本问题解决以后，继续进行测试。结果又提示找不到<code>SANP_HOME</code>路径，我们在环境变量中设置<code>SANP_HOME</code>变量指向到SNAP的安装目录即可。Windows下可以通过<code>This PC</code>属性进行设置，Linux可以在<code>~/.bashrc</code>文件中进行设置，macOS在<code>~/.bash_profile</code>进行设置。我的设置如下：</p><pre class="shell"><code>export SNAP_HOME=/Applications/snap</code></pre><p>最后，我们再继续进行测试，终于看到输出结果了：</p><pre><code>[&#39;radiance_1&#39;, &#39;radiance_2&#39;, &#39;radiance_3&#39;, &#39;radiance_4&#39;, &#39;radiance_5&#39;, &#39;radiance_6&#39;, &#39;radiance_7&#39;, &#39;radiance_8&#39;, &#39;radiance_9&#39;, &#39;radiance_10&#39;, &#39;radiance_11&#39;, &#39;radiance_12&#39;, &#39;radiance_13&#39;, &#39;radiance_14&#39;, &#39;radiance_15&#39;, &#39;l1_flags&#39;, &#39;detector_index&#39;]</code></pre><p>关于snappy接口的具体使用，欢迎关注我的后续文章！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;写作时间：2020年12月4日周末&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;sentinel数据处理工具包snap-python开发环境搭建&quot;&gt;Sentinel数据处理工具包SNAP Python开发环境搭建&lt;/h
      
    
    </summary>
    
      <category term="空间数据处理" scheme="http://theonegis.github.io/categories/geos/"/>
    
    
      <category term="Python" scheme="http://theonegis.github.io/tags/Python/"/>
    
      <category term="SNAP" scheme="http://theonegis.github.io/tags/SNAP/"/>
    
      <category term="Sentinel影像" scheme="http://theonegis.github.io/tags/Sentinel%E5%BD%B1%E5%83%8F/"/>
    
      <category term="snappy" scheme="http://theonegis.github.io/tags/snappy/"/>
    
  </entry>
  
  <entry>
    <title>ESA SNAP工具包Java接口的使用</title>
    <link href="http://theonegis.github.io/geos/ESA-SNAP%E5%B7%A5%E5%85%B7%E5%8C%85Java%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://theonegis.github.io/geos/ESA-SNAP工具包Java接口的使用/</id>
    <published>2020-04-10T14:17:34.000Z</published>
    <updated>2020-04-10T14:53:04.798Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>写作时间：2010年4月10日晚</p><hr><p>欧盟的SNAP工具包提供了对Sentinel卫星数据的处理功能。</p><p>SANP使用Java编写，UI界面使用了NetBeans框架。</p><p>如果要进行批处理的话，还提供了基于图的<strong>G</strong>raph <strong>P</strong>rocessing <strong>F</strong>ramework (GPF)处理模式。</p><p>此外，SNAP还贴心的提供了Python接口snappy（对Java API的封装）。</p><p>参考资料：https://senbox.atlassian.net/wiki/spaces/SNAP/overview</p><p>但是我使用官方提供的安装包安装好以后，Python接口用不了，所以我想着还不如就用原生的Java接口。</p><p>首先，从<a href="https://github.com/senbox-org" target="_blank" rel="noopener">GitHub</a>下载SNAP的源码进行编译，主要下载了<a href="https://github.com/senbox-org/snap-engine" target="_blank" rel="noopener">snap-engine</a>，<a href="https://github.com/senbox-org/snap-desktop" target="_blank" rel="noopener">snap-desktop</a>，<a href="https://github.com/senbox-org/s1tbx" target="_blank" rel="noopener">s1tbx</a>和<a href="https://github.com/senbox-org/s2tbx" target="_blank" rel="noopener">s2tbx</a>这四个工程，依次进行编译（最新版本为8.0.0-SNAPSHOT）。</p><p>例如对snap-engine的编译命令如下：</p><pre class="shell"><code>cd snapgit clone https://github.com/senbox-org/snap-engine.gitcd snap-enginemvn clean install -DskipTests=true</code></pre><p>编译中主要问题是一些第三方库下载特别慢或者根本下载不下来，这时候你需要科学上网手动下载需要的依赖包，再次进行编译。</p><p>编译完这四个包以后，我们新建Maven工程进行代码测试。下面代码使用Better Java （Kotlin）进行示范，我把注释加进了代码中方便理解。</p><pre><code>package cn.demoimport java.nio.file.Pathsimport org.esa.snap.core.dataio.ProductIOfun main(args: Array&lt;String&gt;) {    val path = Paths.get(&quot;S2B_MSIL1C_20200304T032629_N0209_R018_T48SYC_20200304T075000.zip&quot;)    // 通过文件获得读取数据的Reader    val reader = ProductIO.getProductReaderForInput(path.toFile())    // 通过这个Reader对象来读取Sentinel数据产品Product    val product = reader.readProductNodes(path.toFile(), null)    // 通过这个Product对象来读取波段中存储的数据    val band = product.getBand(&quot;B1&quot;)    // 数据不是自动加载的，需要手动加载一下    if (!band.hasRasterData()) {        band.loadRasterData()    }    // 获取波段数据，数据是以一维数组的形式存储的，主要使用PixelInterleavedSampleModel这类进行控制像素交替方式存储    // 有兴趣的可以参考java.awt.image.PixelInterleavedSampleModel    val data = band.rasterData    assert(band.rasterHeight * band.rasterWidth == data.numElems)}</code></pre><p>代码运行过程中，提示找不到OpenJPEG的库（Sentinel-2 SAFE格式的文件中是以JPG图像格式保存各个波段的观测数据的），最后我通过代码调试发现，SNAP中对OpenJPEG库的路径定义在<code>~/.snap/auxdata/openjpeg/8.0.0-SNAPSHOT/</code>目录下，而我的本地没有该目录（虽然<code>/usr/local/bin</code> 目录中有OpenJPEG库，但是SNAP不是在这个目录中寻找的），所以程序会报错。</p><p>解决的方案是我由于本来安装的SNAP桌面版（7.0.0），该版本在<code>~/.snap/auxdata/openjpeg/7.0.0/</code>目录下存放了OpenJPEG库，所以拷贝该版本的库修改名称为<code>8.0.0-SNAPSHOT</code>即可，程序正常运行。</p><p>总得来说，SNAP提供的参考资料不多，有问题只能取Forum中提问。所以我觉得还是使用GDAL读取Sentinel数据，然后再进行进一步操作方便些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;写作时间：2010年4月10日晚&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;欧盟的SNAP工具包提供了对Sentinel卫星数据的处理功能。&lt;/p&gt;
&lt;p&gt;SANP使用Java编写，UI界面使用了NetBeans框架。&lt;/p&gt;
      
    
    </summary>
    
      <category term="空间数据处理" scheme="http://theonegis.github.io/categories/geos/"/>
    
    
      <category term="SANP" scheme="http://theonegis.github.io/tags/SANP/"/>
    
      <category term="Sentinel" scheme="http://theonegis.github.io/tags/Sentinel/"/>
    
      <category term="Java" scheme="http://theonegis.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>macOS下GDAL Java开发环境搭建</title>
    <link href="http://theonegis.github.io/geos/macOS%E4%B8%8BGDAL-Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://theonegis.github.io/geos/macOS下GDAL-Java开发环境搭建/</id>
    <published>2020-04-09T08:58:09.000Z</published>
    <updated>2020-04-09T09:35:52.672Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>写作时间：2020年4月9日下午</p><hr><h1 id="macos下gdal-java开发环境搭建">macOS下GDAL Java开发环境搭建</h1><p>今天在笔记本（macOS平台）上折腾了一下如何搭建GDAL的Java开发环境。虽然GDAL的Python接口更好用，但是有时候需要协同使用一些Java库的时候，也必须使用Java版本的GDAL。</p><p>在macOS上安装GDAL一般有三种方式：</p><ol type="1"><li>使用HomeBrew</li><li>使用<a href="https://www.kyngchaos.com/software/frameworks/" target="_blank" rel="noopener">Kyng-Chaos</a>提供的编译好的二进制包（Framework）</li><li>从源码编译</li></ol><p>由于前两种方式不自带有Java相关的接口，所以这里选择从源码编译。</p><h2 id="gdal源码编译安装">GDAL源码编译安装</h2><p>首先，下载GDAL源码，可以从<a href="https://github.com/OSGeo/gdal" target="_blank" rel="noopener">GitHub</a>上下载，也可以从<a href="https://gdal.org/download.html" target="_blank" rel="noopener">GDAL</a>官网下载。</p><p>我这里从官网下载了最新的2.4.4版本（3.X版本也发布了，但是还是先用稳定一点的吧）的源码进行编译安装。GDAL依赖的库都可以使用HomeBrew安装，我的方法是直接使用Brew安装GDAL，然后再卸载掉GDAL，这样GDAL依赖的第三方库都就自动安装了。</p><p>此外，还需要系统中安装了Java JDK和SWIG以及Ant编译工具。</p><p>下面进行GDAL源码编译并安装到<code>/usr/local</code>目录中。注意配置系统中Java的路径，我这里使用的是JDK11。</p><pre><code>cd gdal-2.4.4./configure --with-threads --disable-static --without-grass --with-jasper=/usr/local/lib --with-libtiff=/usr/local/lib --with-jpeg=/usr/local/lib --with-gif=/usr/local/lib --with-png=/usr/local/lib --with-geotiff=/usr/local/lib --with-pcraster=internal --with-geos=/usr/local/lib --with-static-proj4=/usr/local/lib --with-expat=/usr/local/lib --with-curl=/usr/local/lib --with-netcdf=/usr/local/lib --with-hdf5=/usr/local/lib --with-opencl --with-libz=internal --without-python --with-java --with-jvm-lib=/Library/Java/JavaVirtualMachines/openjdk-11.0.2.jdk/Contents/Home makesudo make install</code></pre><p>然后接下来我们编译Java接口需要的相关文件。<code>make install</code>命令会将动态链接库<code>libgdalalljni.20.dylib</code>和<code>libgdalalljni.dylib</code>拷贝到<code>/usr/local/lib</code>目录中。</p><pre><code>cd swig/javamake CFLAGS=&quot;-I/Library/Java/JavaVirtualMachines/openjdk-11.0.2.jdk/Contents/Home/include -I//Library/Java/JavaVirtualMachines/openjdk-11.0.2.jdk/Contents/Home/include/darwin&quot;sudo make install</code></pre><p><code>make</code>命令会生成我们需要的<code>gdal.jar</code>包，是我们做Java开发需要的依赖包，必须添加到工程中。</p><p>我以为这样就可以了，但是当我在工程中调用GDAL的时候，提示找不到Native Library，然后我就把<code>libgdalalljni.20.dylib</code>和<code>libgdalalljni.dylib</code>又拷贝到了<code>/Library/Java/Extensions</code>目录中，问题才得以解决。</p><h2 id="maven安装本地jar">Maven安装本地JAR</h2><p>我习惯使用Maven管理依赖，但是Maven中央仓库中没有提供GDAL 2.4.4版本的JAR包。所以需要把刚才生成的<code>gdal.jar</code>文件安装到本地Maven仓库中，这样才能在Maven工程中使用。</p><p>使用如下命令进行安装以后，我们就可以在工程中开心的使用了！</p><pre><code>mvn install:install-file -Dfile=/Users/TheOneGIS/Development/gdal-2.4.4/swig/java/gdal.jar -DgroupId=org.gdal -DartifactId=gdal -Dversion=2.4.4 -Dpackaging=jar</code></pre><h2 id="使用java版gdal示例">使用Java版GDAL示例</h2><p>这里使用Better Java（Kotlin）语言进行一个简单的Shapefile文件读取的示例。首先，新建Maven Kotlin工程；然后在POM文件中添加GDAL依赖，最后书写我们的HelloWorld示例。</p><div class="sourceCode" id="cb4"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">&lt;dependency&gt;</span></span><span id="cb4-2"><a href="#cb4-2"></a>  <span class="kw">&lt;groupId&gt;</span>org.gdal<span class="kw">&lt;/groupId&gt;</span></span><span id="cb4-3"><a href="#cb4-3"></a>  <span class="kw">&lt;artifactId&gt;</span>gdal<span class="kw">&lt;/artifactId&gt;</span></span><span id="cb4-4"><a href="#cb4-4"></a>  <span class="kw">&lt;version&gt;</span>2.4.4<span class="kw">&lt;/version&gt;</span></span><span id="cb4-5"><a href="#cb4-5"></a><span class="kw">&lt;/dependency&gt;</span></span></code></pre></div><p>示例代码如下：</p><div class="sourceCode" id="cb5"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">package</span> <span class="im">cn.demo</span></span><span id="cb5-2"><a href="#cb5-2"></a></span><span id="cb5-3"><a href="#cb5-3"></a><span class="kw">import</span> <span class="im">org.gdal.gdal.*</span></span><span id="cb5-4"><a href="#cb5-4"></a></span><span id="cb5-5"><a href="#cb5-5"></a><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</span><span id="cb5-6"><a href="#cb5-6"></a>    <span class="co">// 初始化GDAL环境</span></span><span id="cb5-7"><a href="#cb5-7"></a>    gdal.UseExceptions()</span><span id="cb5-8"><a href="#cb5-8"></a>    gdal.AllRegister()</span><span id="cb5-9"><a href="#cb5-9"></a>    </span><span id="cb5-10"><a href="#cb5-10"></a>        <span class="co">// 读取数据，输出数据信息</span></span><span id="cb5-11"><a href="#cb5-11"></a>    <span class="kw">val</span> <span class="va">path</span> = <span class="st">&quot;China.shp&quot;</span></span><span id="cb5-12"><a href="#cb5-12"></a>    <span class="kw">val</span> <span class="va">ds</span> = gdal.OpenEx(path)</span><span id="cb5-13"><a href="#cb5-13"></a>    <span class="kw">val</span> <span class="va">layer</span> = ds.GetLayer(<span class="dv">0</span>)</span><span id="cb5-14"><a href="#cb5-14"></a>    println(layer.GetName())</span><span id="cb5-15"><a href="#cb5-15"></a>    <span class="cf">for</span> (i <span class="kw">in</span> <span class="dv">0</span> until layer.GetFeatureCount()) {</span><span id="cb5-16"><a href="#cb5-16"></a>        print(layer.GetNextFeature().GetFieldAsString(<span class="st">&quot;NAME&quot;</span>))</span><span id="cb5-17"><a href="#cb5-17"></a>    }</span><span id="cb5-18"><a href="#cb5-18"></a>    ds.delete()</span><span id="cb5-19"><a href="#cb5-19"></a>}</span></code></pre></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;写作时间：2020年4月9日下午&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;macos下gdal-java开发环境搭建&quot;&gt;macOS下GDAL Java开发环境搭建&lt;/h1&gt;
&lt;p&gt;今天在笔记本（macOS平台）上折
      
    
    </summary>
    
      <category term="空间数据处理" scheme="http://theonegis.github.io/categories/geos/"/>
    
    
      <category term="Java" scheme="http://theonegis.github.io/tags/Java/"/>
    
      <category term="GDAL" scheme="http://theonegis.github.io/tags/GDAL/"/>
    
      <category term="Maven" scheme="http://theonegis.github.io/tags/Maven/"/>
    
      <category term="macOS" scheme="http://theonegis.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>UNIX系统下删除老旧Maven依赖包的方法</title>
    <link href="http://theonegis.github.io/tools/UNIX%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%88%A0%E9%99%A4%E8%80%81%E6%97%A7Maven%E4%BE%9D%E8%B5%96%E5%8C%85%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://theonegis.github.io/tools/UNIX系统下删除老旧Maven依赖包的方法/</id>
    <published>2020-04-08T13:13:00.000Z</published>
    <updated>2020-04-08T13:33:43.279Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>写作时间：2020年4月8日晚</p><hr><h1 id="unix系统下删除老旧maven依赖包的方法">UNIX系统下删除老旧Maven依赖包的方法</h1><p>笔记本是macOS，磁盘只有256，Maven下载的依赖包，特别是老旧的JAR很占空间，如何使用一行命令删除这些依赖包呢？</p><p>基本思想是使用<code>find</code>命令找出来给定时间段没有使用过的JAR包（通过POM文件的时间戳判断），然后使用<code>rm</code>命令进行删除。</p><p>下面的命令通过遍历<code>~/.m2</code>文件夹下修改时间大于5天的以<code>.pom</code>为扩展名的文件，然后删除该POM文件所在的父文件夹。</p><pre><code>find ~/.m2 -ctime +5d -iname &#39;*.pom&#39; | while read pom; do parent=`dirname &quot;$pom&quot;`; rm -rf &quot;$parent&quot;</code></pre><p>下面稍微看一下<code>find</code>命令，我们可以通过<code>-atime</code>和<code>-ctime</code>分别给出查找文件的最后访问时间获最后修改时间到当前的时间间隔（时间单位可以是s，m，h，d，w，分别代表秒，分钟，小时，天和周）。此外，我们可以直接通过<code>-amin</code>和<code>-cmin</code>分别指定以分钟为单位的时常。具体命令的使用可以使用<code>man find</code>进行查看。</p><p>最后要说的是，在进行正式删除之前建议通过Dry Run查看一下那些文件要删除，不要删错了以后后悔莫及！ 所以在正式删除之前，先试试下面的命令吧！</p><pre><code>find ~/.m2 -ctime +5d -iname &#39;*.pom&#39; | while read pom; do parent=`dirname &quot;$pom&quot;`; echo &quot;$parent&quot;; done &gt; output.txt</code></pre><p>Windows下的删除没有试过，不过应该可以使用对应的BAT批处理相关命令进行操作。如果对于Windows 10，我们可以采用Linux子系统（WSL）进行操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;写作时间：2020年4月8日晚&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;unix系统下删除老旧maven依赖包的方法&quot;&gt;UNIX系统下删除老旧Maven依赖包的方法&lt;/h1&gt;
&lt;p&gt;笔记本是macOS，磁盘只有25
      
    
    </summary>
    
      <category term="工具" scheme="http://theonegis.github.io/categories/tools/"/>
    
    
      <category term="Maven" scheme="http://theonegis.github.io/tags/Maven/"/>
    
      <category term="JAR包" scheme="http://theonegis.github.io/tags/JAR%E5%8C%85/"/>
    
      <category term="Linux" scheme="http://theonegis.github.io/tags/Linux/"/>
    
      <category term="MacOS" scheme="http://theonegis.github.io/tags/MacOS/"/>
    
      <category term="find" scheme="http://theonegis.github.io/tags/find/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你用QGIS制作地图</title>
    <link href="http://theonegis.github.io/geos/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8QGIS%E5%88%B6%E4%BD%9C%E5%9C%B0%E5%9B%BE/"/>
    <id>http://theonegis.github.io/geos/手把手教你用QGIS制作地图/</id>
    <published>2020-04-07T13:15:44.000Z</published>
    <updated>2020-04-07T14:12:27.355Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>写作时间：2020年7月4日晚</p><hr><h1 id="手把手教你使用qgis制作地图">手把手教你使用QGIS制作地图</h1><p>QGIS是一款开源免费的地理信息系统软件，虽然比不上商业的ArcGIS软件，但是QGIS免费而且跨平台，值得学习！</p><p>今天我们聊聊如何使用QGIS进行地图制作并输出。对任意一幅地图的制作下面介绍的步骤并不是都要用得到，我会分知识点进行介绍，学习一些常用地图制作技巧。</p><p>下面我们一步一步进行吧！（我是在macOS平台下进行操作的，Windows平台界面可能稍有差异）</p><h2 id="加载矢量数据">加载矢量数据</h2><p>打开QGIS，从文件管理面板Browser加载所要的数据，如下图所示（以陕西省为例）。</p><figure><img src="/images/geos/making-a-map/屏幕快照%202020-04-07%20下午8.56.03.png" alt=""><figcaption>屏幕快照 2020-04-07 下午8.56.03</figcaption></figure><h2 id="加载背景底图">加载背景底图</h2><p>底图的加载我们可以有很多选择，比如使用OpenStreetMap或者谷歌地图。当然，我们也可以选择不使用底图。</p><p>下面给出加载底图的步骤：</p><p>在文件管理面板Browser的XYZ Tiles节点上右键，选择New Connection…，然后在弹出的对话框中输出Name和URL。下图给出了OpenStreetMap的添加界面。</p><figure><img src="/images/geos/making-a-map/屏幕快照%202020-04-07%20下午8.56.24.png" alt=""><figcaption>屏幕快照 2020-04-07 下午8.56.24</figcaption></figure><p>添加完Connection以后，直接点击添加的地图服务节点将底图添加到我们的工程。</p><p>鼠标在图层Layers面板中拖动数据层的顺序，将刚添加的底图移动到最下方的位置。如下图所示。</p><figure><img src="/images/geos/making-a-map/屏幕快照%202020-04-07%20下午8.56.41.png" alt=""><figcaption>屏幕快照 2020-04-07 下午8.56.41</figcaption></figure><p>此外，这里附上谷歌地图服务的地址，方便有需要的朋友使用：</p><p><strong>Google Maps</strong>: https://mt1.google.com/vt/lyrs=r&amp;x={x}&amp;y={y}&amp;z={z}</p><p><strong>Google Satellite:</strong> http://www.google.cn/maps/vt?lyrs=s@189&amp;gl=cn&amp;x={x}&amp;y={y}&amp;z={z}</p><p><strong>Google Satellite Hybrid:</strong> https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}</p><p><strong>Google Terrain:</strong> https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}</p><p><strong>Google Roads:</strong> https://mt1.google.com/vt/lyrs=h&amp;x={x}&amp;y={y}&amp;z={z}</p><p>拿走不谢！</p><h2 id="美化矢量数据">美化矢量数据</h2><p>在Layers面板中选中数据层，右键选择Properties…，在弹出的对话框中选择左侧列表中的Symbology，然后设置矢量数据的填充（Fill），边线（Stroke）等。</p><figure><img src="/images/geos/making-a-map/屏幕快照%202020-04-07%20下午9.43.53.png" alt=""><figcaption>屏幕快照 2020-04-07 下午9.43.53</figcaption></figure><h2 id="添加晕线">添加晕线</h2><p>地图制作中有时候需要给行政边界添加晕线，制作方法很简单。思路是这样的：首先，给原始行政区做缓冲区，然后添加缓冲区到原始行政区图层下面，设置缓冲区的边线的颜色粗细。</p><p>注意：我在使用QGIS的过程中，通过菜单栏Vector-&gt;Geoprocessing Tools-&gt;Buffer…工具进行缓冲区制作的时候，发现制作的缓冲区地理坐标不对（和原始的行政区地理间隔很大），我也不找到出错的原因。</p><p>我通过菜单栏Processing-&gt;Toolbox打开QGIS工具箱，使用GDAL提供的Buffer工具，则不会出现错误，如下图（QGIS中集成了GDAL，GRASS等开源GIS工具，所以经常在处理一个任务的时候，我们有多个工具可以选择）。</p><figure><img src="/images/geos/making-a-map/屏幕快照%202020-04-07%20下午9.00.53.png" alt=""><figcaption>屏幕快照 2020-04-07 下午9.00.53</figcaption></figure><p>做完缓冲区之后，我们需要对缓冲区进行美化（你自己认为漂亮即可），效果如下图！</p><figure><img src="/images/geos/making-a-map/屏幕快照%202020-04-07%20下午9.02.43.png" alt=""><figcaption>屏幕快照 2020-04-07 下午9.02.43</figcaption></figure><h2 id="切换到排版视图">切换到排版视图</h2><p>在ArcGIS中我们一般在进行地图输出的时候一般会切换到布局视图（好像是叫Layotu View，如果我没记错的话）进行地图整饰和出图。</p><p>在QGIS中也是类似的，我们需要点击工具栏的New Print Layout（我的在保存Save Project按钮旁边，我的节目自己调整过，所以可能和标准界面不一样）。这时候会出现一个新的Tab面板（对应ArcGIS的布局视图），我们在该选项卡面板中进行操作，如下图所示。</p><figure><img src="/images/geos/making-a-map/屏幕快照%202020-04-07%20下午9.59.15.png" alt=""><figcaption>屏幕快照 2020-04-07 下午9.59.15</figcaption></figure><p>在布局视图面板的左侧有一系列工具，我们首先点击Add Map按钮，在空白画布上拖动一个地图范围，这样我们刚才制作的地图就会显示在该画布上面。</p><figure><img src="/images/geos/making-a-map/屏幕快照%202020-04-07%20下午9.04.17.png" alt=""><figcaption>屏幕快照 2020-04-07 下午9.04.17</figcaption></figure><h2 id="添加经纬度格网">添加经纬度格网</h2><p>下面我们添加经纬度格网，在该视图的右边Items选项卡中选择我们的地图对象，然后在Item Properties选项卡中，选择Grids节点进行展开，点击➕按钮添加一个Grid对象，然后点击Modify Grid按钮编辑格网的属性。</p><p>我们可以设置格网显示的坐标系，格网显示的间隔，格网显示的样式等等。根据自己的需求自由发挥吧！</p><figure><img src="/images/geos/making-a-map/屏幕快照%202020-04-07%20下午9.04.38.png" alt=""><figcaption>屏幕快照 2020-04-07 下午9.04.38</figcaption></figure><h2 id="添加其他修饰元素">添加其他修饰元素</h2><p>此外，我们还可以点击面板右边的按钮添加比例尺、图例、图名、指北针等等修饰元素。这里不做详细介绍，自己慢慢探索吧！添加完以后，如下图。</p><figure><img src="/images/geos/making-a-map/屏幕快照%202020-04-07%20下午9.14.00.png" alt=""><figcaption>屏幕快照 2020-04-07 下午9.14.00</figcaption></figure><h2 id="地图输出">地图输出</h2><p>最后我们要将地图输出为PDF或者图片格式进行保存，在工具栏提供了相应的按钮进行操作。</p><p>我这里想说的是在QGIS地图制作过程中如果添加了地图服务（Web-Service-Based Map），则有可能在输出保存的时候，底图的显示不太对（会有缩放），我们的矢量地图不存在问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;写作时间：2020年7月4日晚&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;手把手教你使用qgis制作地图&quot;&gt;手把手教你使用QGIS制作地图&lt;/h1&gt;
&lt;p&gt;QGIS是一款开源免费的地理信息系统软件，虽然比不上商业的A
      
    
    </summary>
    
      <category term="空间数据处理" scheme="http://theonegis.github.io/categories/geos/"/>
    
    
      <category term="QGIS" scheme="http://theonegis.github.io/tags/QGIS/"/>
    
      <category term="地图制作" scheme="http://theonegis.github.io/tags/%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C/"/>
    
      <category term="地图输出" scheme="http://theonegis.github.io/tags/%E5%9C%B0%E5%9B%BE%E8%BE%93%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>从傅立叶级数到傅立叶变化</title>
    <link href="http://theonegis.github.io/math/%E4%BB%8E%E5%82%85%E7%AB%8B%E5%8F%B6%E7%BA%A7%E6%95%B0%E5%88%B0%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E5%8C%96/"/>
    <id>http://theonegis.github.io/math/从傅立叶级数到傅立叶变化/</id>
    <published>2019-10-31T11:09:32.000Z</published>
    <updated>2019-10-31T12:29:06.727Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>写作时间：2019-10-31</p><hr><p>写这篇博文的初衷是在翻阅数字图像处理相关教科书的时候，发现大部分对傅立叶变换的讲解直接给出了变换公式，而对于公式从何而来并没有给出说明。所以，本文在假设已经了解傅立叶级数的背景下，从傅立叶级数推导出傅立叶变换的一般公式。</p><h1 id="傅立叶级数">傅立叶级数</h1><p>学过高数的童鞋都听过傅立叶级数，下面直接给出定义，具体证明可以参考高等数学教材。</p><p>设周期为<span class="math inline">\(T\)</span>的周期函数<span class="math inline">\(f(x)\)</span>的傅立叶级数为</p><p><span class="math display">\[f(x) = \frac{a_{0}}{2}+\sum_{n=1}^{\infty}\left(a_{n} \cos \frac{2\pi n x}{T}+b_{n} \sin \frac{2\pi n x}{T}\right) \tag{1}\]</span></p><p>其中，系数<span class="math inline">\(a_n\)</span>和<span class="math inline">\(b_n\)</span>分别为：</p><p><span class="math display">\[\left.\begin{array}{ll}{a_{n}=\frac{2}{T} \int_{\frac{T}{2}}^{\frac{T}{2}} f(x) \cos \frac{2\pi n x}{T} \mathrm{d} x} &amp; {(n=0,1,2, \cdots)} \\ {b_{n}=\frac{2}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f(x) \sin \frac{2\pi n x}{T} \mathrm{d} x} &amp; {(n=1,2,3, \cdots)}\end{array}\right\} \tag{2}\]</span></p><p>利用欧拉公式<span class="math display">\[\cos t=\frac{\mathrm{e}^{t \mathrm{i}}+\mathrm{e}^{-t i}}{2}, \quad \sin t=\frac{\mathrm{e}^{t i}-\mathrm{e}^{-t i}}{2 \mathrm{i}}\]</span></p><p>可以将公式（1）转化为傅立叶级数的复数形式</p><p><span class="math display">\[f(x) = \sum\limits_{n=-\infty}^{\infty} c_{n} e^{\frac{2\pi n x}{T} \mathrm{i}} \tag{3}\]</span></p><p>系数<span class="math inline">\(c_n\)</span>为</p><p><span class="math display">\[c_{n}=\frac{1}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f(x) \mathrm{e}^{-\frac{2\pi n x}{T} \mathrm{i}} \mathrm{d} x \quad(n=0, \pm 1, \pm 2, \cdots) \tag{4}\]</span></p><p>傅立叶级数的两种形式本质上是一样的，但是复数形式比较简洁，而且只用一个算式计算系数。</p><h1 id="傅立叶变换">傅立叶变换</h1><p>傅立叶级数是针对周期函数的，为了可以处理非周期函数，需要傅立叶变换。</p><p>傅立叶变换将周期函数在一个周期内的部分无限延拓，即让周期趋紧于无穷，然后就得到了傅立叶变换，如下图所示。</p><figure><img src="/images/math/FourierTransform.jpeg" alt=""><figcaption>非周期函数延拓</figcaption></figure><p>图片来源：<a href="https://medium.com/sho-jp/fourier-transform-101-part-3-fourier-transform-6def0bd2ca9b" target="_blank" rel="noopener">Fourier Transform 101 — Part 3: Fourier Transform</a></p><p>下面我们看一下，当周期<span class="math inline">\(T\)</span>趋于<span class="math inline">\(\infty\)</span>的时候，我们看一下公式（3）和（4）的变化。</p><p>令<span class="math inline">\(\frac{1}{T} = \Delta \omega\)</span>，则</p><p><span class="math display">\[\begin{align}f(x) &amp;= \sum\limits_{n=-\infty}^{\infty} c_{n} e^{\frac{2 \pi n x}{T} \mathrm{i}} \\ &amp;= \sum\limits_{n=-\infty}^{\infty} c_{n} e^{2 \pi n \Delta \omega x \mathrm{i}} \\ &amp;= \sum\limits_{n=-\infty}^{\infty} \frac{1}{T} [\int_{-\frac{T}{2}}^{\frac{T}{2}} f(x) \mathrm{e}^{-2\pi n \Delta \omega x \mathrm{i}} \mathrm{d} x] e^{2 \pi n \Delta \omega x \mathrm{i}} \\ \end{align}\]</span></p><p>当<span class="math inline">\(T \to \infty\)</span>时，<span class="math inline">\(\Delta \omega \to 0\)</span>，<span class="math inline">\(\Delta \omega \to \mathrm{d}\omega\)</span> ，<span class="math inline">\(\mathrm{d}\omega\)</span>和<span class="math inline">\(n \mathrm{d}\omega\)</span>都成为连续的变量，记为<span class="math inline">\(\omega\)</span>。</p><p><span class="math display">\[\begin{align}f(x) &amp;= \lim_{T\to \infty}{\sum\limits_{n=-\infty}^{\infty} \frac{1}{T} [\int_{-\frac{T}{2}}^{\frac{T}{2}} f(x) \mathrm{e}^{-n \pi xl \mathrm{i}} \mathrm{d} x] e^{2 \pi n \Delta \omega x \mathrm{i}}} \\ &amp;= \int_{-\infty}^{\infty}[\int_{-\infty}^{\infty}f(x)e^{-2\pi\omega x \mathrm{i}} \mathrm{d}x]e^{2\pi\omega x \mathrm{i}}\mathrm{d}\omega \\ \end{align}\]</span></p><p>对应于傅立叶级数，傅立叶变换可以表示为</p><p><span class="math display">\[F(\omega) = \int_{-\infty}^{\infty}f(x)e^{-2\pi\omega x \mathrm{i}} \mathrm{d}x \tag{5}\]</span></p><p>而相应地傅立叶逆变换可以表示为</p><p><span class="math display">\[f(x) = \int_{-\infty}^{\infty}F(\omega) e^{2\pi\omega x \mathrm{i}}\mathrm{d}\omega \tag{6}\]</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;写作时间：2019-10-31&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;写这篇博文的初衷是在翻阅数字图像处理相关教科书的时候，发现大部分对傅立叶变换的讲解直接给出了变换公式，而对于公式从何而来并没有给出说明。所以，本文在假设
      
    
    </summary>
    
      <category term="数学" scheme="http://theonegis.github.io/categories/math/"/>
    
    
      <category term="傅立叶变换" scheme="http://theonegis.github.io/tags/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    
      <category term="傅立叶级数" scheme="http://theonegis.github.io/tags/%E5%82%85%E7%AB%8B%E5%8F%B6%E7%BA%A7%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Morton码</title>
    <link href="http://theonegis.github.io/algorithm/Morton%E7%A0%81/"/>
    <id>http://theonegis.github.io/algorithm/Morton码/</id>
    <published>2019-07-08T09:11:27.000Z</published>
    <updated>2019-10-31T12:31:45.630Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>写作时间：2019-07-08 17:11:27</p><hr><h1 id="morton码的计算">Morton码的计算</h1><p>Morton码是对栅格格网进行编码的一种算法，在Google中搜索Morton，搜索结果第一位是Wikipedia的Z-order Curve，这是因为Morton码编码结果展现为一种Z形的填充曲线。下面简要说一下如何计算四进制和十进制的Morton码。</p><figure><img src="/images/geos/z-curve.png" alt=""><figcaption>Morton码二进制</figcaption></figure><h2 id="四进制morton码计算">四进制Morton码计算</h2><p>四进制编码对左上，右上，左下，右下的顺序对四个格网单元分布编码为0，1，2，3。</p><p>其计算方式为：二进制的行列号<span class="math inline">\(r\)</span>、<span class="math inline">\(l\)</span>（从第0行0列开始），四进制编码<span class="math inline">\(M=2*l+ r\)</span>；那么这里就是：第5行（101）第7列（111）：<span class="math inline">\(M=2*101+111=313\)</span>（313对应的十进制是55）</p><h2 id="十进制morton码计算">十进制Morton码计算</h2><p>十进制的编码规则：首先，行列号转为二进制（从第0行0列开始）；然后行列号交叉排列；最后将二进制结果转为十进制。十进制Morton编码是按左上，右上，左下，右下的顺序从0开始对每个格网进行自然编码的。</p><p>对于第5行（101）第7列（111），交叉排列得到110111，然后转为十进制就是55。和四进制的编码结果是一样的。</p><p>下面给出十进制Morton码的C++实现：</p><div class="sourceCode" id="cb1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span><span id="cb1-2"><a href="#cb1-2"></a></span><span id="cb1-3"><a href="#cb1-3"></a><span class="kw">using</span> <span class="bu">std::</span>cout;</span><span id="cb1-4"><a href="#cb1-4"></a></span><span id="cb1-5"><a href="#cb1-5"></a><span class="dt">int</span> main() {</span><span id="cb1-6"><a href="#cb1-6"></a>    <span class="dt">uint32_t</span> row = <span class="dv">5</span>;</span><span id="cb1-7"><a href="#cb1-7"></a>    <span class="dt">uint32_t</span> col = <span class="dv">7</span>;</span><span id="cb1-8"><a href="#cb1-8"></a>    <span class="dt">uint64_t</span> morton = <span class="dv">0</span>;</span><span id="cb1-9"><a href="#cb1-9"></a></span><span id="cb1-10"><a href="#cb1-10"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="kw">sizeof</span>(row) * <span class="dv">8</span>; i++) {</span><span id="cb1-11"><a href="#cb1-11"></a>        morton |= (row &amp; (<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; i) &lt;&lt; i | (col &amp; (<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; i) &lt;&lt; (i + <span class="dv">1</span>);</span><span id="cb1-12"><a href="#cb1-12"></a>    }</span><span id="cb1-13"><a href="#cb1-13"></a>    cout &lt;&lt; morton &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span><span id="cb1-14"><a href="#cb1-14"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span><span id="cb1-15"><a href="#cb1-15"></a>}</span></code></pre></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;写作时间：2019-07-08 17:11:27&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;morton码的计算&quot;&gt;Morton码的计算&lt;/h1&gt;
&lt;p&gt;Morton码是对栅格格网进行编码的一种算法，在Google中
      
    
    </summary>
    
      <category term="算法" scheme="http://theonegis.github.io/categories/algorithm/"/>
    
    
      <category term="Morton" scheme="http://theonegis.github.io/tags/Morton/"/>
    
  </entry>
  
  <entry>
    <title>NumPy中的维度Axis</title>
    <link href="http://theonegis.github.io/python/NumPy%E4%B8%AD%E7%9A%84%E7%BB%B4%E5%BA%A6Axis/"/>
    <id>http://theonegis.github.io/python/NumPy中的维度Axis/</id>
    <published>2019-04-16T06:56:53.000Z</published>
    <updated>2019-04-16T19:35:24.935Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>写作时间：2019-04-16 14:56:53</p><hr><h1 id="浅谈numpy中的维度axis">浅谈NumPy中的维度Axis</h1><p>NumPy中的维度是一个很重要的概念，很多函数的参数都需要给定维度Axis，如何直观的理解维度呢？我们首先以二维数组为例进行说明，然后推广到多维数组。</p><p>(有人将<code>ndim</code>属性叫维度，将<code>axis</code>叫轴，我还是习惯将<code>axis</code>称之为维度，<code>axis=0</code>称为第一个维度)</p><h2 id="二维数组的列子">二维数组的列子</h2><p>下面是一个二维数组的列子：</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a>In [<span class="dv">1</span>]: <span class="im">import</span> numpy <span class="im">as</span> np</span><span id="cb1-2"><a href="#cb1-2"></a></span><span id="cb1-3"><a href="#cb1-3"></a>In [<span class="dv">2</span>]: x <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">9</span>, (<span class="dv">2</span>, <span class="dv">3</span>))</span><span id="cb1-4"><a href="#cb1-4"></a></span><span id="cb1-5"><a href="#cb1-5"></a>In [<span class="dv">3</span>]: x</span><span id="cb1-6"><a href="#cb1-6"></a>Out[<span class="dv">3</span>]:</span><span id="cb1-7"><a href="#cb1-7"></a>array([[<span class="dv">0</span>, <span class="dv">8</span>, <span class="dv">6</span>],</span><span id="cb1-8"><a href="#cb1-8"></a>       [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>]])</span><span id="cb1-9"><a href="#cb1-9"></a></span><span id="cb1-10"><a href="#cb1-10"></a>In [<span class="dv">4</span>]: x.ndim</span><span id="cb1-11"><a href="#cb1-11"></a>Out[<span class="dv">4</span>]: <span class="dv">2</span></span><span id="cb1-12"><a href="#cb1-12"></a></span><span id="cb1-13"><a href="#cb1-13"></a>In [<span class="dv">5</span>]: x.shape</span><span id="cb1-14"><a href="#cb1-14"></a>Out[<span class="dv">5</span>]: (<span class="dv">2</span>, <span class="dv">3</span>)</span><span id="cb1-15"><a href="#cb1-15"></a></span><span id="cb1-16"><a href="#cb1-16"></a>In [<span class="dv">6</span>]: x[<span class="dv">0</span>]</span><span id="cb1-17"><a href="#cb1-17"></a>Out[<span class="dv">6</span>]: array([<span class="dv">0</span>, <span class="dv">8</span>, <span class="dv">6</span>])</span><span id="cb1-18"><a href="#cb1-18"></a></span><span id="cb1-19"><a href="#cb1-19"></a>In [<span class="dv">7</span>]: x[:, <span class="dv">0</span>]</span><span id="cb1-20"><a href="#cb1-20"></a>Out[<span class="dv">7</span>]: array([<span class="dv">0</span>, <span class="dv">1</span>])</span><span id="cb1-21"><a href="#cb1-21"></a></span><span id="cb1-22"><a href="#cb1-22"></a>In [<span class="dv">8</span>]: x.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)</span><span id="cb1-23"><a href="#cb1-23"></a>Out[<span class="dv">8</span>]: array([ <span class="dv">1</span>, <span class="dv">10</span>,  <span class="dv">7</span>])</span><span id="cb1-24"><a href="#cb1-24"></a></span><span id="cb1-25"><a href="#cb1-25"></a>In [<span class="dv">9</span>]: x.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span><span id="cb1-26"><a href="#cb1-26"></a>Out[<span class="dv">9</span>]: array([<span class="dv">14</span>,  <span class="dv">4</span>])</span><span id="cb1-27"><a href="#cb1-27"></a></span><span id="cb1-28"><a href="#cb1-28"></a>In [<span class="dv">10</span>]: x[<span class="dv">0</span>] <span class="op">+</span> x[<span class="dv">1</span>]</span><span id="cb1-29"><a href="#cb1-29"></a>Out[<span class="dv">10</span>]: array([ <span class="dv">1</span>, <span class="dv">10</span>,  <span class="dv">7</span>])</span><span id="cb1-30"><a href="#cb1-30"></a></span><span id="cb1-31"><a href="#cb1-31"></a>In [<span class="dv">11</span>]: x[:, <span class="dv">0</span>] <span class="op">+</span> x[:, <span class="dv">1</span>] <span class="op">+</span> x[:, <span class="dv">2</span>]</span><span id="cb1-32"><a href="#cb1-32"></a>Out[<span class="dv">11</span>]: array([<span class="dv">14</span>,  <span class="dv">4</span>])</span></code></pre></div><p>看上面这个例子，<code>x</code>是一个2行3列的数组，所以<code>x</code>是一个二维数组。</p><p>从第6和第7个输入输出，我们可以肯定地说“对于二维数组，第一维指的是行，第二维指的是列”。</p><p>我们通过<code>sum</code>求和函数，探究一下<code>x</code>的第一维和第二维的意义？从第8个和第9个输入输出，我们可以看到对于参数<code>axis=0</code>，其结果是数组列的和；而对于参数<code>axis=1</code>，其参数是数组行的和。</p><p>对于<code>axis=0</code>第一个维度求和，不是将第一维度（行）中的所有元素相加，而是沿着第一个维度，将对应其他维度（列）的数据相加，分解开来就是第10个输入输出。同理，对于<code>axis=1</code>，是沿着列，将行中的元素相加。</p><p>NumPy中对于维度的操作都是以类似这样的逻辑操作的。</p><h2 id="多维数组">多维数组</h2><p>对于多维数组我们如何准确区分维度呢？下面以图示进行说明：</p><figure><img src="/images/python/NumPy中的维度.png" alt=""><figcaption>NumPy中的维度</figcaption></figure><p>所以，我的结论就是：在概念上维度是从整体到局部看的，最外围的是第一个维度，然后依次往里，最内部的就是最后一维。</p><p>下面我们用代码验证一下上面的结论：</p><div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>In [<span class="dv">19</span>]: x <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">9</span>, (<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>))</span><span id="cb2-2"><a href="#cb2-2"></a></span><span id="cb2-3"><a href="#cb2-3"></a>In [<span class="dv">20</span>]: x</span><span id="cb2-4"><a href="#cb2-4"></a>Out[<span class="dv">20</span>]:</span><span id="cb2-5"><a href="#cb2-5"></a>array([[[<span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">5</span>],</span><span id="cb2-6"><a href="#cb2-6"></a>        [<span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">3</span>],</span><span id="cb2-7"><a href="#cb2-7"></a>        [<span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">4</span>]],</span><span id="cb2-8"><a href="#cb2-8"></a></span><span id="cb2-9"><a href="#cb2-9"></a>       [[<span class="dv">8</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">6</span>],</span><span id="cb2-10"><a href="#cb2-10"></a>        [<span class="dv">8</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">8</span>],</span><span id="cb2-11"><a href="#cb2-11"></a>        [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">8</span>, <span class="dv">2</span>]]])</span><span id="cb2-12"><a href="#cb2-12"></a></span><span id="cb2-13"><a href="#cb2-13"></a>In [<span class="dv">21</span>]: x[<span class="dv">0</span>]</span><span id="cb2-14"><a href="#cb2-14"></a>Out[<span class="dv">21</span>]:</span><span id="cb2-15"><a href="#cb2-15"></a>array([[<span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">5</span>],</span><span id="cb2-16"><a href="#cb2-16"></a>       [<span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">3</span>],</span><span id="cb2-17"><a href="#cb2-17"></a>       [<span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">4</span>]])</span><span id="cb2-18"><a href="#cb2-18"></a></span><span id="cb2-19"><a href="#cb2-19"></a>In [<span class="dv">22</span>]: x[:, <span class="dv">0</span>, :]</span><span id="cb2-20"><a href="#cb2-20"></a>Out[<span class="dv">22</span>]:</span><span id="cb2-21"><a href="#cb2-21"></a>array([[<span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">5</span>],</span><span id="cb2-22"><a href="#cb2-22"></a>       [<span class="dv">8</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">6</span>]])</span></code></pre></div><p>可以看到，第21个输入输出取到的是第一维的第一个元素，第22个输入输出取到的是第二维的第一个元素。大家可以细细体味一下！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;写作时间：2019-04-16 14:56:53&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;浅谈numpy中的维度axis&quot;&gt;浅谈NumPy中的维度Axis&lt;/h1&gt;
&lt;p&gt;NumPy中的维度是一个很重要的概念，很多
      
    
    </summary>
    
      <category term="Python" scheme="http://theonegis.github.io/categories/python/"/>
    
    
      <category term="NumPy" scheme="http://theonegis.github.io/tags/NumPy/"/>
    
  </entry>
  
  <entry>
    <title>栅格数据裁剪</title>
    <link href="http://theonegis.github.io/geos/%E6%A0%85%E6%A0%BC%E6%95%B0%E6%8D%AE%E8%A3%81%E5%89%AA/"/>
    <id>http://theonegis.github.io/geos/栅格数据裁剪/</id>
    <published>2019-03-22T07:35:09.000Z</published>
    <updated>2019-03-22T19:39:16.792Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！ 写作时间：2019-03-22</p><p>在进行遥感影像处理的时候，我们经常需要进行裁剪的工作，来看看如何使用GDAL工具进行这项操作吧！</p><p>参考资料：</p><ol type="1"><li><a href="https://www.gdal.org/gdalwarp.html" target="_blank" rel="noopener">GDAL: gdalwarp</a></li><li><a href="https://www.gdal.org/gdal_translate.html" target="_blank" rel="noopener">GDAL: gdal_translate</a></li><li><a href="https://gdal.org/python/" target="_blank" rel="noopener">GDAL/OGR Python API</a></li></ol><h2 id="使用gdal命令">使用GDAL命令</h2><p>GDAL提供了两个命令可以用于影像的裁剪：<code>gdalwarp</code>和<code>gdal_translate</code>，两个命令中我更推荐使用后者。</p><p><code>gdalwarp</code>命令可以使用<code>-te</code>制定裁剪范围。默认是在原数据的坐标系下的<code>xmin ymin xmax ymax</code>，当然我们也可以使用<code>-te_srs</code>参数指定<code>-te</code>参数所在的坐标系。</p><p>为什么不推荐<code>gdalwarp</code>命令呢？这是因为<code>gdalwarp</code>命令只提供了根据坐标系的范围进行裁剪，而不支持根据行列号的裁剪。这时候我们可以求助于<code>gdal_translate</code>命令。</p><p><code>gdal_transalte</code>命令即支持使用<code>-srcwin</code>参数指定行列号范围<code>xoff yoff xsize ysize</code>，也支持使用<code>-projwin</code>参数指定原数据坐标系下的范围<code>ulx uly lrx lry</code>。同时提供参数<code>-projwin_srs</code>可以用于指定<code>-projwin</code>参数所在的坐标系，即跟<code>gdalwarp</code>命令中的<code>-te_srs</code>参数类似。</p><p>下面给出一个示例：</p><p><code>gdal_translate -of "GTiff" -srcwin 10 10 256 256 -a_scale 1 HDF4_EOS:EOS_GRID:"MOD09GA.A2018349.h26v05.006.2018351030314.hdf":MODIS_Grid_500m_2D:sur_refl_b01_1 sr_1.tif</code></p><p>这行命令将MODIS数据中的反射率的第一波段进行裁剪，起点为第10行第10列，输出大小为256$$255，输出格式为TIFF。</p><p>注意这行命令有一个<code>-a_scale 1</code>参数，这个参数指定了裁剪过程不要对DN值进行缩放。如果不加这个值得话，输出图像的DN值会被根据原数据的<code>Scale=10000</code>放大10000倍。</p><h2 id="使用python代码">使用Python代码</h2><p>对于使用Python代码进行裁剪，我们有两种方法：</p><ul><li>第一就是对命令行对应的借口直接进行调用。这个最直接最简单。</li><li>第二就是首先自己选择出需要裁剪的区域，然后计算裁剪区域的GeoTransform的系数，最后将投影和GeoTransform系数赋值给裁剪子区域，写入输出文件。</li></ul><p>我们知道<a href="https://blog.csdn.net/theonegis/article/details/80304873" target="_blank" rel="noopener">GDAL中使用了六参数模型存储GeoTransform参数</a>，如果进行矩形裁剪的话，只有<code>GT(0)</code>和<code>GT(3)</code>参数会有变化，即需要重新计算裁剪以后的左上角坐标即可。</p><p>下面给出使用Python对MODIS反射率的第一波段进行裁剪的代码：</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">from</span> osgeo <span class="im">import</span> gdal</span><span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span><span id="cb1-3"><a href="#cb1-3"></a></span><span id="cb1-4"><a href="#cb1-4"></a><span class="co"># API参考：https://gdal.org/python/</span></span><span id="cb1-5"><a href="#cb1-5"></a><span class="co"># GDAL命令行参考：https://www.gdal.org/gdal_translate.html</span></span><span id="cb1-6"><a href="#cb1-6"></a>image_name <span class="op">=</span> (<span class="st">&#39;HDF4_EOS:EOS_GRID:&#39;</span></span><span id="cb1-7"><a href="#cb1-7"></a>              <span class="st">&#39;&quot;MOD09GA.A2018349.h26v05.006.2018351030314.hdf&quot;:&#39;</span></span><span id="cb1-8"><a href="#cb1-8"></a>              <span class="st">&#39;MODIS_Grid_500m_2D:sur_refl_b01_1&#39;</span>)</span><span id="cb1-9"><a href="#cb1-9"></a></span><span id="cb1-10"><a href="#cb1-10"></a><span class="co"># 第一种方式，也是最简单的方法：直接使用GDAL命令行对应的Python方法</span></span><span id="cb1-11"><a href="#cb1-11"></a>src: gdal.Dataset <span class="op">=</span> gdal.Open(image_name)</span><span id="cb1-12"><a href="#cb1-12"></a>src <span class="op">=</span> gdal.Translate(<span class="st">&#39;cropped_with_translate.tif&#39;</span>, src, srcWin<span class="op">=</span>[<span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">256</span>, <span class="dv">256</span>],</span><span id="cb1-13"><a href="#cb1-13"></a>                     options<span class="op">=</span>[<span class="st">&#39;-a_scale&#39;</span>, <span class="st">&#39;1&#39;</span>])</span><span id="cb1-14"><a href="#cb1-14"></a><span class="kw">del</span> src</span><span id="cb1-15"><a href="#cb1-15"></a></span><span id="cb1-16"><a href="#cb1-16"></a><span class="co"># 第二种方式，自己选择出需要的像素，然后自己确定裁剪以后的空间参考关系，并写入到输出文件</span></span><span id="cb1-17"><a href="#cb1-17"></a>src: gdal.Dataset <span class="op">=</span> gdal.Open(image_name)</span><span id="cb1-18"><a href="#cb1-18"></a>band: gdal.Band <span class="op">=</span> src.GetRasterBand(<span class="dv">1</span>)</span><span id="cb1-19"><a href="#cb1-19"></a>subset: np.ndarray <span class="op">=</span> band.ReadAsArray(<span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">256</span>, <span class="dv">256</span>)</span><span id="cb1-20"><a href="#cb1-20"></a></span><span id="cb1-21"><a href="#cb1-21"></a>driver: gdal.Driver <span class="op">=</span> gdal.GetDriverByName(<span class="st">&#39;GTiff&#39;</span>)</span><span id="cb1-22"><a href="#cb1-22"></a>dst: gdal.Dataset <span class="op">=</span> driver.Create(<span class="st">&#39;cropped_from_scratch.tif&#39;</span>, <span class="dv">256</span>, <span class="dv">256</span>, <span class="dv">1</span>, gdal.GDT_Int16)</span><span id="cb1-23"><a href="#cb1-23"></a>dst.SetProjection(src.GetProjection())</span><span id="cb1-24"><a href="#cb1-24"></a>trans <span class="op">=</span> <span class="bu">list</span>(src.GetGeoTransform())</span><span id="cb1-25"><a href="#cb1-25"></a>trans[<span class="dv">0</span>] <span class="op">-=</span> <span class="op">-</span><span class="dv">10</span> <span class="op">*</span> trans[<span class="dv">1</span>]</span><span id="cb1-26"><a href="#cb1-26"></a>trans[<span class="dv">3</span>] <span class="op">-=</span> <span class="op">-</span><span class="dv">10</span> <span class="op">*</span> trans[<span class="dv">5</span>]</span><span id="cb1-27"><a href="#cb1-27"></a>dst.SetGeoTransform(<span class="bu">tuple</span>(trans))</span><span id="cb1-28"><a href="#cb1-28"></a></span><span id="cb1-29"><a href="#cb1-29"></a>band: gdal.Band <span class="op">=</span> dst.GetRasterBand(<span class="dv">1</span>)</span><span id="cb1-30"><a href="#cb1-30"></a>band.WriteArray(subset)</span><span id="cb1-31"><a href="#cb1-31"></a>band.FlushCache()</span><span id="cb1-32"><a href="#cb1-32"></a><span class="kw">del</span> src</span><span id="cb1-33"><a href="#cb1-33"></a><span class="kw">del</span> dst</span></code></pre></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！ 写作时间：2019-03-22&lt;/p&gt;
&lt;p&gt;在进行遥感影像处理的时候，我们经常需要进行裁剪的工作，来看看如何使用GDAL工具进行这项操作吧！&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
      <category term="空间数据处理" scheme="http://theonegis.github.io/categories/geos/"/>
    
    
      <category term="Python" scheme="http://theonegis.github.io/tags/Python/"/>
    
      <category term="GDAL" scheme="http://theonegis.github.io/tags/GDAL/"/>
    
      <category term="裁剪" scheme="http://theonegis.github.io/tags/%E8%A3%81%E5%89%AA/"/>
    
  </entry>
  
  <entry>
    <title>Python中如何优雅地使用switch语句</title>
    <link href="http://theonegis.github.io/python/Python%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8switch%E8%AF%AD%E5%8F%A5/"/>
    <id>http://theonegis.github.io/python/Python中如何优雅地使用switch语句/</id>
    <published>2019-03-07T05:49:45.000Z</published>
    <updated>2019-03-22T19:39:53.825Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>写作时间：2019-03-07 13:49:45</p><h1 id="python中如何优雅地使用switch语句">Python中如何优雅地使用switch语句</h1><p>我们知道Python中没有类似C++或者Java中的<code>switch...case</code>语句，我们可以使用多个<code>if...elif...else</code>进行模拟，但是这样的写法让代码看起来很凌乱，个人不是很推荐在代码中大量使用<code>if</code>语句。</p><p>那么解决的办法是什么呢？答曰：字典（<code>dict</code>）。下面我们以两个典型案例进行说明。</p><h2 id="案例一简单情况">案例一（简单情况）</h2><p>第一种简单情况就是一对一，给定一个值，返回一个值，这是C++和Java中的<code>switch</code>语句支持的情况。</p><p>下面的案例是将英文日期翻译为中文日期：</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a>dates <span class="op">=</span> {</span><span id="cb1-2"><a href="#cb1-2"></a>    <span class="st">&#39;Sun&#39;</span>: <span class="st">&#39;星期天&#39;</span>, <span class="st">&#39;Mon&#39;</span>: <span class="st">&#39;星期一&#39;</span>, <span class="st">&#39;Tues&#39;</span>: <span class="st">&#39;星期二&#39;</span>, <span class="st">&#39;Wed&#39;</span>: <span class="st">&#39;星期三&#39;</span>,</span><span id="cb1-3"><a href="#cb1-3"></a>    <span class="st">&#39;Thurs&#39;</span>: <span class="st">&#39;星期四&#39;</span>, <span class="st">&#39;Fri&#39;</span>: <span class="st">&#39;星期五&#39;</span>, <span class="st">&#39;Sat&#39;</span>: <span class="st">&#39;星期六&#39;</span>}</span><span id="cb1-4"><a href="#cb1-4"></a></span><span id="cb1-5"><a href="#cb1-5"></a>day <span class="op">=</span> dates.get(<span class="st">&#39;Fri&#39;</span>, <span class="st">&#39;未知&#39;</span>)</span><span id="cb1-6"><a href="#cb1-6"></a><span class="bu">print</span>(day)  <span class="co"># 输出结果为星期五</span></span></code></pre></div><h2 id="案例二带条件判断">案例二（带条件判断）</h2><p>第二种情况是多对一，反映在编程上就是<code>case</code>语句中带条件判断，这个是诸如Scala中的<code>switch</code>和Kotlin中的<code>when</code>支持的情况。</p><p>下面给出的案例是给定一个数字，如果该数字在某个范围之类，则返回一个指定的数字。</p><div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># 这里的conditions是一个函数</span></span><span id="cb2-2"><a href="#cb2-2"></a>conditions <span class="op">=</span> <span class="kw">lambda</span> x: {</span><span id="cb2-3"><a href="#cb2-3"></a>    x <span class="op">&lt;</span> <span class="op">-</span><span class="dv">1</span>: <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span> <span class="op">&lt;=</span> x <span class="op">&lt;=</span> <span class="dv">1</span>: <span class="fl">0.5</span>, x <span class="op">&gt;</span> <span class="dv">1</span>: <span class="dv">1</span></span><span id="cb2-4"><a href="#cb2-4"></a>}</span><span id="cb2-5"><a href="#cb2-5"></a></span><span id="cb2-6"><a href="#cb2-6"></a>num <span class="op">=</span> conditions(<span class="fl">0.25</span>)[<span class="va">True</span>]</span><span id="cb2-7"><a href="#cb2-7"></a><span class="bu">print</span>(num)</span><span id="cb2-8"><a href="#cb2-8"></a>num <span class="op">=</span> conditions(<span class="dv">10</span>)[<span class="va">True</span>]</span><span id="cb2-9"><a href="#cb2-9"></a><span class="bu">print</span>(num)</span></code></pre></div><p>这里我们的<code>dict</code>不是一个普通的字典，其<code>key</code>是一个<code>lambda</code>表达式（一个函数）。如果我们调用该函数，则会返回一个字典，该字典中有两个元素：一个元素的键是<code>True</code>，另一个是<code>False</code>。<code>True</code>元素包含的值是对应<code>lambda</code>函数中满足条件的给定值，<code>False</code>元素包含的值是对应<code>lambda</code>函数中最后一个不满足条件的给定值（这句话写得比较拗口，不好理解。动手实践一下，可以加深理解）。</p><p>经过上面的介绍，我们以后可以大大减少对<code>if...else</code>语句的使用了，让我们的代码更加干净一些！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;写作时间：2019-03-07 13:49:45&lt;/p&gt;
&lt;h1 id=&quot;python中如何优雅地使用switch语句&quot;&gt;Python中如何优雅地使用switch语句&lt;/h1&gt;
&lt;p&gt;我们知道Python中没
      
    
    </summary>
    
      <category term="Python" scheme="http://theonegis.github.io/categories/python/"/>
    
    
      <category term="Python" scheme="http://theonegis.github.io/tags/Python/"/>
    
      <category term="Switch" scheme="http://theonegis.github.io/tags/Switch/"/>
    
  </entry>
  
  <entry>
    <title>使用卷积网络做手写数字识别</title>
    <link href="http://theonegis.github.io/dl/%E4%BD%BF%E7%94%A8%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%E5%81%9A%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://theonegis.github.io/dl/使用卷积网络做手写数字识别/</id>
    <published>2019-03-02T14:24:22.000Z</published>
    <updated>2019-03-22T19:39:53.829Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>写作时间：2019-03-02 22:24:22</p><h1 id="使用卷积网络做手写数字识别">使用卷积网络做手写数字识别</h1><h2 id="思路分析">思路分析</h2><p>上篇博文《<a href="https://theonegis.blog.csdn.net/article/details/88086423" target="_blank" rel="noopener">使用循环神经网络做手写数字识别</a>》介绍了利用LSTM做手写数字的识别，想着好事成双，也写一个姊妹篇卷积网络实现手写数字的识别。</p><p>博文主要通过最简单的代码量展示一个入门级别的识别案例。需要注意的几点：</p><ul><li>卷积网络的输入大小为（<code>batch_size</code>，<code>num_channels</code>，<code>image_width</code>，<code>image_height</code>）</li><li>本文中的模型使用了卷积层和线性连接层。Linear层的输入大小为（<code>*</code>，<code>num_input_feature</code>），所以在卷积层输出流入线性层的时候，需要转化一下张量的尺寸大小</li><li>综合使用<code>MaxPooling</code>层和<code>Dropout</code>层可以提高识别准确率</li></ul><h2 id="pytorch实现">PyTorch实现</h2><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> torch</span><span id="cb1-2"><a href="#cb1-2"></a><span class="im">from</span> torch <span class="im">import</span> nn</span><span id="cb1-3"><a href="#cb1-3"></a><span class="im">import</span> torchvision.datasets <span class="im">as</span> datasets</span><span id="cb1-4"><a href="#cb1-4"></a><span class="im">import</span> torchvision.transforms <span class="im">as</span> transforms</span><span id="cb1-5"><a href="#cb1-5"></a></span><span id="cb1-6"><a href="#cb1-6"></a>torch.manual_seed(<span class="dv">2019</span>)</span><span id="cb1-7"><a href="#cb1-7"></a></span><span id="cb1-8"><a href="#cb1-8"></a><span class="co"># 超参设置</span></span><span id="cb1-9"><a href="#cb1-9"></a>EPOCH <span class="op">=</span> <span class="dv">1</span>  <span class="co"># 训练EPOCH次，这里为了测试方便只跑一次</span></span><span id="cb1-10"><a href="#cb1-10"></a>BATCH_SIZE <span class="op">=</span> <span class="dv">32</span></span><span id="cb1-11"><a href="#cb1-11"></a>INIT_LR <span class="op">=</span> <span class="fl">1e-3</span>  <span class="co"># 初始学习率</span></span><span id="cb1-12"><a href="#cb1-12"></a>DOWNLOAD_MNIST <span class="op">=</span> <span class="va">True</span>  <span class="co"># 设置是否需要下载数据集</span></span><span id="cb1-13"><a href="#cb1-13"></a></span><span id="cb1-14"><a href="#cb1-14"></a><span class="co"># 使用DataLoader加载训练数据，为了演示方便，对于测试数据只取出2000个样本进行测试</span></span><span id="cb1-15"><a href="#cb1-15"></a>train_data <span class="op">=</span> datasets.MNIST(root<span class="op">=</span><span class="st">&#39;mnist&#39;</span>, train<span class="op">=</span><span class="va">True</span>, transform<span class="op">=</span>transforms.ToTensor(), download<span class="op">=</span>DOWNLOAD_MNIST)</span><span id="cb1-16"><a href="#cb1-16"></a>train_loader <span class="op">=</span> torch.utils.data.DataLoader(dataset<span class="op">=</span>train_data, batch_size<span class="op">=</span>BATCH_SIZE, shuffle<span class="op">=</span><span class="va">True</span>)</span><span id="cb1-17"><a href="#cb1-17"></a>test_data <span class="op">=</span> datasets.MNIST(root<span class="op">=</span><span class="st">&#39;mnist&#39;</span>, train<span class="op">=</span><span class="va">False</span>)</span><span id="cb1-18"><a href="#cb1-18"></a>test_x <span class="op">=</span> test_data.test_data.<span class="bu">type</span>(torch.FloatTensor)[:<span class="dv">2000</span>] <span class="op">/</span> <span class="fl">255.</span></span><span id="cb1-19"><a href="#cb1-19"></a>test_x.unsqueeze_(<span class="dv">1</span>)  <span class="co"># 调整test_x的尺寸为四维，添加了一个channel维度</span></span><span id="cb1-20"><a href="#cb1-20"></a>test_y <span class="op">=</span> test_data.test_labels.numpy()[:<span class="dv">2000</span>]</span><span id="cb1-21"><a href="#cb1-21"></a></span><span id="cb1-22"><a href="#cb1-22"></a></span><span id="cb1-23"><a href="#cb1-23"></a><span class="kw">class</span> ConvNet(nn.Module):</span><span id="cb1-24"><a href="#cb1-24"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span><span id="cb1-25"><a href="#cb1-25"></a>        <span class="bu">super</span>(ConvNet, <span class="va">self</span>).<span class="fu">__init__</span>()</span><span id="cb1-26"><a href="#cb1-26"></a>        <span class="va">self</span>.conv <span class="op">=</span> nn.Sequential(</span><span id="cb1-27"><a href="#cb1-27"></a>            nn.Conv2d(<span class="dv">1</span>, <span class="dv">32</span>, <span class="dv">5</span>),  <span class="co"># 图像输出大小为24*24</span></span><span id="cb1-28"><a href="#cb1-28"></a>            nn.MaxPool2d(<span class="dv">2</span>),  <span class="co"># 图像输出大小为12*12</span></span><span id="cb1-29"><a href="#cb1-29"></a>            nn.ReLU(<span class="va">True</span>),</span><span id="cb1-30"><a href="#cb1-30"></a>            nn.Conv2d(<span class="dv">32</span>, <span class="dv">64</span>, <span class="dv">5</span>),  <span class="co"># 图像输出大小为8*8</span></span><span id="cb1-31"><a href="#cb1-31"></a>            nn.Dropout2d(),</span><span id="cb1-32"><a href="#cb1-32"></a>            nn.MaxPool2d(<span class="dv">2</span>),  <span class="co"># 图像输出大小为4*4</span></span><span id="cb1-33"><a href="#cb1-33"></a>            nn.ReLU(<span class="va">True</span>)</span><span id="cb1-34"><a href="#cb1-34"></a>        )</span><span id="cb1-35"><a href="#cb1-35"></a></span><span id="cb1-36"><a href="#cb1-36"></a>        <span class="va">self</span>.linear <span class="op">=</span> nn.Sequential(</span><span id="cb1-37"><a href="#cb1-37"></a>            nn.Linear(<span class="dv">4</span> <span class="op">*</span> <span class="dv">4</span> <span class="op">*</span> <span class="dv">64</span>, <span class="dv">128</span>),</span><span id="cb1-38"><a href="#cb1-38"></a>            nn.ReLU(<span class="va">True</span>),</span><span id="cb1-39"><a href="#cb1-39"></a>            nn.Dropout2d(),</span><span id="cb1-40"><a href="#cb1-40"></a>            nn.Linear(<span class="dv">128</span>, <span class="dv">10</span>),</span><span id="cb1-41"><a href="#cb1-41"></a>            nn.Softmax(<span class="dv">1</span>)</span><span id="cb1-42"><a href="#cb1-42"></a>        )</span><span id="cb1-43"><a href="#cb1-43"></a></span><span id="cb1-44"><a href="#cb1-44"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span><span id="cb1-45"><a href="#cb1-45"></a>        x <span class="op">=</span> <span class="va">self</span>.conv(x)</span><span id="cb1-46"><a href="#cb1-46"></a>        x <span class="op">=</span> x.view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">4</span> <span class="op">*</span> <span class="dv">4</span> <span class="op">*</span> <span class="dv">64</span>)</span><span id="cb1-47"><a href="#cb1-47"></a>        out <span class="op">=</span> <span class="va">self</span>.linear(x)</span><span id="cb1-48"><a href="#cb1-48"></a>        <span class="cf">return</span> out</span><span id="cb1-49"><a href="#cb1-49"></a></span><span id="cb1-50"><a href="#cb1-50"></a></span><span id="cb1-51"><a href="#cb1-51"></a>model <span class="op">=</span> ConvNet()</span><span id="cb1-52"><a href="#cb1-52"></a><span class="bu">print</span>(model)</span><span id="cb1-53"><a href="#cb1-53"></a></span><span id="cb1-54"><a href="#cb1-54"></a>optimizer <span class="op">=</span> torch.optim.Adam(model.parameters(), lr<span class="op">=</span>INIT_LR)</span><span id="cb1-55"><a href="#cb1-55"></a>loss_func <span class="op">=</span> nn.CrossEntropyLoss()</span><span id="cb1-56"><a href="#cb1-56"></a></span><span id="cb1-57"><a href="#cb1-57"></a><span class="co"># RNN训练</span></span><span id="cb1-58"><a href="#cb1-58"></a><span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(EPOCH):</span><span id="cb1-59"><a href="#cb1-59"></a>    <span class="cf">for</span> index, (b_x, b_y) <span class="kw">in</span> <span class="bu">enumerate</span>(train_loader):</span><span id="cb1-60"><a href="#cb1-60"></a>        model.train()</span><span id="cb1-61"><a href="#cb1-61"></a>        <span class="co"># 输入尺寸为(batch_size, channels, height, width)</span></span><span id="cb1-62"><a href="#cb1-62"></a>        output <span class="op">=</span> model(b_x)  <span class="co"># (64, 1, 28, 28)</span></span><span id="cb1-63"><a href="#cb1-63"></a>        loss <span class="op">=</span> loss_func(output, b_y)</span><span id="cb1-64"><a href="#cb1-64"></a>        optimizer.zero_grad()</span><span id="cb1-65"><a href="#cb1-65"></a>        loss.backward()</span><span id="cb1-66"><a href="#cb1-66"></a>        optimizer.step()</span><span id="cb1-67"><a href="#cb1-67"></a></span><span id="cb1-68"><a href="#cb1-68"></a>        <span class="cf">if</span> index <span class="op">%</span> <span class="dv">50</span> <span class="op">==</span> <span class="dv">0</span>:</span><span id="cb1-69"><a href="#cb1-69"></a>            model.<span class="bu">eval</span>()</span><span id="cb1-70"><a href="#cb1-70"></a>            prediction <span class="op">=</span> model(test_x)  <span class="co"># 输出为(2000, 10)</span></span><span id="cb1-71"><a href="#cb1-71"></a>            pred_y <span class="op">=</span> torch.<span class="bu">max</span>(prediction, <span class="dv">1</span>)[<span class="dv">1</span>].data.numpy()</span><span id="cb1-72"><a href="#cb1-72"></a>            accuracy <span class="op">=</span> (pred_y <span class="op">==</span> test_y).<span class="bu">sum</span>() <span class="op">/</span> <span class="bu">float</span>(test_y.size)</span><span id="cb1-73"><a href="#cb1-73"></a>            <span class="bu">print</span>(<span class="ss">f&#39;Epoch: [</span><span class="sc">{</span>index<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">]&#39;</span>, <span class="ss">f&#39;| train loss: </span><span class="sc">{</span>loss<span class="sc">.</span>item()<span class="sc">}</span><span class="ss">&#39;</span>, <span class="ss">f&#39;| test accuracy: </span><span class="sc">{</span>accuracy<span class="sc">}</span><span class="ss">&#39;</span>)</span><span id="cb1-74"><a href="#cb1-74"></a></span><span id="cb1-75"><a href="#cb1-75"></a><span class="co"># 打印测试数据集中的后20个结果</span></span><span id="cb1-76"><a href="#cb1-76"></a>model.<span class="bu">eval</span>()</span><span id="cb1-77"><a href="#cb1-77"></a>prediction <span class="op">=</span> model(test_x[:<span class="dv">20</span>])</span><span id="cb1-78"><a href="#cb1-78"></a>pred_y <span class="op">=</span> torch.<span class="bu">max</span>(prediction, <span class="dv">1</span>)[<span class="dv">1</span>].data.numpy()</span><span id="cb1-79"><a href="#cb1-79"></a><span class="bu">print</span>(pred_y, <span class="st">&#39;prediction number&#39;</span>)</span><span id="cb1-80"><a href="#cb1-80"></a><span class="bu">print</span>(test_y[:<span class="dv">20</span>], <span class="st">&#39;real number&#39;</span>)</span></code></pre></div><p>训练结果如下，可以看到对于这种不太复杂的问题，CNN和RNN都可以得到比较高的精度。</p><figure><img src="/images/ml/CNN-MNIST.png" alt=""><figcaption>使用卷积网络做手写数字识别</figcaption></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;写作时间：2019-03-02 22:24:22&lt;/p&gt;
&lt;h1 id=&quot;使用卷积网络做手写数字识别&quot;&gt;使用卷积网络做手写数字识别&lt;/h1&gt;
&lt;h2 id=&quot;思路分析&quot;&gt;思路分析&lt;/h2&gt;
&lt;p&gt;上篇博文《&lt;
      
    
    </summary>
    
      <category term="深度学习" scheme="http://theonegis.github.io/categories/dl/"/>
    
    
      <category term="PyTorch" scheme="http://theonegis.github.io/tags/PyTorch/"/>
    
      <category term="卷积神经网络" scheme="http://theonegis.github.io/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="CNN" scheme="http://theonegis.github.io/tags/CNN/"/>
    
      <category term="手写识别" scheme="http://theonegis.github.io/tags/%E6%89%8B%E5%86%99%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>使用循环神经网络做手写数字识别</title>
    <link href="http://theonegis.github.io/dl/%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%81%9A%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://theonegis.github.io/dl/使用循环神经网络做手写数字识别/</id>
    <published>2019-03-02T13:36:12.000Z</published>
    <updated>2019-03-22T19:39:53.830Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为博主原创文章，转载请注明原文出处！</p><p>写作时间：2019-03-02 21:36:12</p><h1 id="使用循环神经网络做手写数字识别">使用循环神经网络做手写数字识别</h1><h2 id="思路分析">思路分析</h2><p>做图像识别的使用卷积神经网络CNN是最好的选择，但是其实我们也可以使用循环神经网络RNN做，只是大部分时候没有卷积网络效果好！下面分析一下如何使用RNN做手写数字的识别。</p><ol type="1"><li>数据的下载我们可以直接使用PyTorch中的<code>torchvision.datasets</code>提供的数据接口</li><li>对于每一张图像（28$$28）我们可以将图像的每一行看做一个样本，然后所有行排列起来做成一个有序序列。对于这个序列，我们就可以使用RNN做识别训练了。</li><li>下面的实现中使用一个LSTM+Linear层组合实现（不要使用经典RNN，效果不好），损失函数使用CrossEntropyLoss。</li><li>在实践中设置<code>batch_first=True</code>可以减少一些额外的维度变换和尺寸转换的代码，推荐使用</li></ol><h2 id="pytorch实现">PyTorch实现</h2><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> torch</span><span id="cb1-2"><a href="#cb1-2"></a><span class="im">from</span> torch <span class="im">import</span> nn</span><span id="cb1-3"><a href="#cb1-3"></a><span class="im">import</span> torchvision.datasets <span class="im">as</span> datasets</span><span id="cb1-4"><a href="#cb1-4"></a><span class="im">import</span> torchvision.transforms <span class="im">as</span> transforms</span><span id="cb1-5"><a href="#cb1-5"></a></span><span id="cb1-6"><a href="#cb1-6"></a>torch.manual_seed(<span class="dv">2019</span>)</span><span id="cb1-7"><a href="#cb1-7"></a></span><span id="cb1-8"><a href="#cb1-8"></a><span class="co"># 超参设置</span></span><span id="cb1-9"><a href="#cb1-9"></a>EPOCH <span class="op">=</span> <span class="dv">1</span>  <span class="co"># 训练EPOCH次，这里为了测试方便只跑一次</span></span><span id="cb1-10"><a href="#cb1-10"></a>BATCH_SIZE <span class="op">=</span> <span class="dv">32</span></span><span id="cb1-11"><a href="#cb1-11"></a>TIME_STEP <span class="op">=</span> <span class="dv">28</span>  <span class="co"># RNN时间跨度（图片高度）</span></span><span id="cb1-12"><a href="#cb1-12"></a>INPUT_SIZE <span class="op">=</span> <span class="dv">28</span>  <span class="co"># RNN输入尺寸（图片宽度）</span></span><span id="cb1-13"><a href="#cb1-13"></a>INIT_LR <span class="op">=</span> <span class="fl">0.01</span>  <span class="co"># 初始学习率</span></span><span id="cb1-14"><a href="#cb1-14"></a>DOWNLOAD_MNIST <span class="op">=</span> <span class="va">True</span>  <span class="co"># 设置是否需要下载数据集</span></span><span id="cb1-15"><a href="#cb1-15"></a></span><span id="cb1-16"><a href="#cb1-16"></a><span class="co"># 使用DataLoader加载训练数据，为了演示方便，对于测试数据只取出2000个样本进行测试</span></span><span id="cb1-17"><a href="#cb1-17"></a>train_data <span class="op">=</span> datasets.MNIST(root<span class="op">=</span><span class="st">&#39;mnist&#39;</span>, train<span class="op">=</span><span class="va">True</span>, transform<span class="op">=</span>transforms.ToTensor(), download<span class="op">=</span>DOWNLOAD_MNIST)</span><span id="cb1-18"><a href="#cb1-18"></a>train_loader <span class="op">=</span> torch.utils.data.DataLoader(dataset<span class="op">=</span>train_data, batch_size<span class="op">=</span>BATCH_SIZE, shuffle<span class="op">=</span><span class="va">True</span>)</span><span id="cb1-19"><a href="#cb1-19"></a>test_data <span class="op">=</span> datasets.MNIST(root<span class="op">=</span><span class="st">&#39;mnist&#39;</span>, train<span class="op">=</span><span class="va">False</span>)</span><span id="cb1-20"><a href="#cb1-20"></a>test_x <span class="op">=</span> test_data.test_data.<span class="bu">type</span>(torch.FloatTensor)[:<span class="dv">2000</span>] <span class="op">/</span> <span class="fl">255.</span></span><span id="cb1-21"><a href="#cb1-21"></a>test_y <span class="op">=</span> test_data.test_labels.numpy()[:<span class="dv">2000</span>]</span><span id="cb1-22"><a href="#cb1-22"></a></span><span id="cb1-23"><a href="#cb1-23"></a></span><span id="cb1-24"><a href="#cb1-24"></a><span class="kw">class</span> RNN(nn.Module):</span><span id="cb1-25"><a href="#cb1-25"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span><span id="cb1-26"><a href="#cb1-26"></a>        <span class="bu">super</span>(RNN, <span class="va">self</span>).<span class="fu">__init__</span>()</span><span id="cb1-27"><a href="#cb1-27"></a>        <span class="va">self</span>.rnn <span class="op">=</span> nn.LSTM(</span><span id="cb1-28"><a href="#cb1-28"></a>            input_size<span class="op">=</span>INPUT_SIZE,</span><span id="cb1-29"><a href="#cb1-29"></a>            hidden_size<span class="op">=</span><span class="dv">64</span>,</span><span id="cb1-30"><a href="#cb1-30"></a>            num_layers<span class="op">=</span><span class="dv">1</span>,</span><span id="cb1-31"><a href="#cb1-31"></a>            batch_first<span class="op">=</span><span class="va">True</span></span><span id="cb1-32"><a href="#cb1-32"></a>        )</span><span id="cb1-33"><a href="#cb1-33"></a>        <span class="va">self</span>.out <span class="op">=</span> nn.Linear(<span class="dv">64</span>, <span class="dv">10</span>)</span><span id="cb1-34"><a href="#cb1-34"></a></span><span id="cb1-35"><a href="#cb1-35"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span><span id="cb1-36"><a href="#cb1-36"></a>        <span class="co"># x shape (batch_size, time_step, input_size)</span></span><span id="cb1-37"><a href="#cb1-37"></a>        <span class="co"># r_out shape (batch_size, time_step, output_size)</span></span><span id="cb1-38"><a href="#cb1-38"></a>        <span class="co"># h_n shape (n_layers, batch_size, hidden_size)</span></span><span id="cb1-39"><a href="#cb1-39"></a>        <span class="co"># h_c shape (n_layers, batch_size, hidden_size)</span></span><span id="cb1-40"><a href="#cb1-40"></a>        r_out, (h_n, h_c) <span class="op">=</span> <span class="va">self</span>.rnn(x)</span><span id="cb1-41"><a href="#cb1-41"></a>        <span class="co"># 取出最后一次循环的r_out传递到全连接层</span></span><span id="cb1-42"><a href="#cb1-42"></a>        out <span class="op">=</span> <span class="va">self</span>.out(r_out[:, <span class="op">-</span><span class="dv">1</span>, :])</span><span id="cb1-43"><a href="#cb1-43"></a>        <span class="cf">return</span> out</span><span id="cb1-44"><a href="#cb1-44"></a></span><span id="cb1-45"><a href="#cb1-45"></a></span><span id="cb1-46"><a href="#cb1-46"></a>rnn <span class="op">=</span> RNN()</span><span id="cb1-47"><a href="#cb1-47"></a><span class="bu">print</span>(rnn)</span><span id="cb1-48"><a href="#cb1-48"></a></span><span id="cb1-49"><a href="#cb1-49"></a>optimizer <span class="op">=</span> torch.optim.Adam(rnn.parameters(), lr<span class="op">=</span>INIT_LR)</span><span id="cb1-50"><a href="#cb1-50"></a>loss_func <span class="op">=</span> nn.CrossEntropyLoss()</span><span id="cb1-51"><a href="#cb1-51"></a></span><span id="cb1-52"><a href="#cb1-52"></a><span class="co"># RNN训练</span></span><span id="cb1-53"><a href="#cb1-53"></a><span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(EPOCH):</span><span id="cb1-54"><a href="#cb1-54"></a>    <span class="cf">for</span> step, (b_x, b_y) <span class="kw">in</span> <span class="bu">enumerate</span>(train_loader):</span><span id="cb1-55"><a href="#cb1-55"></a>        <span class="co"># 数据的输入为(batch_size, time_step, input_size)</span></span><span id="cb1-56"><a href="#cb1-56"></a>        b_x <span class="op">=</span> b_x.view(<span class="op">-</span><span class="dv">1</span>, TIME_STEP, INPUT_SIZE)</span><span id="cb1-57"><a href="#cb1-57"></a>        output <span class="op">=</span> rnn(b_x)</span><span id="cb1-58"><a href="#cb1-58"></a>        loss <span class="op">=</span> loss_func(output, b_y)</span><span id="cb1-59"><a href="#cb1-59"></a>        optimizer.zero_grad()</span><span id="cb1-60"><a href="#cb1-60"></a>        loss.backward()</span><span id="cb1-61"><a href="#cb1-61"></a>        optimizer.step()</span><span id="cb1-62"><a href="#cb1-62"></a></span><span id="cb1-63"><a href="#cb1-63"></a>        <span class="cf">if</span> step <span class="op">%</span> <span class="dv">50</span> <span class="op">==</span> <span class="dv">0</span>:</span><span id="cb1-64"><a href="#cb1-64"></a>            prediction <span class="op">=</span> rnn(test_x)  <span class="co"># 输出为(2000, 10)</span></span><span id="cb1-65"><a href="#cb1-65"></a>            pred_y <span class="op">=</span> torch.<span class="bu">max</span>(prediction, <span class="dv">1</span>)[<span class="dv">1</span>].data.numpy()</span><span id="cb1-66"><a href="#cb1-66"></a>            accuracy <span class="op">=</span> (pred_y <span class="op">==</span> test_y).<span class="bu">sum</span>() <span class="op">/</span> <span class="bu">float</span>(test_y.size)</span><span id="cb1-67"><a href="#cb1-67"></a>            <span class="bu">print</span>(<span class="ss">f&#39;Epoch: [</span><span class="sc">{</span>step<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">]&#39;</span>, <span class="ss">f&#39;| train loss: </span><span class="sc">{</span>loss<span class="sc">.</span>item()<span class="sc">}</span><span class="ss">&#39;</span>, <span class="ss">f&#39;| test accuracy: </span><span class="sc">{</span>accuracy<span class="sc">}</span><span class="ss">&#39;</span>)</span><span id="cb1-68"><a href="#cb1-68"></a></span><span id="cb1-69"><a href="#cb1-69"></a><span class="co"># 打印测试数据集中的后20个结果</span></span><span id="cb1-70"><a href="#cb1-70"></a>prediction <span class="op">=</span> rnn(test_x[:<span class="dv">20</span>].view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">28</span>, <span class="dv">28</span>))</span><span id="cb1-71"><a href="#cb1-71"></a>pred_y <span class="op">=</span> torch.<span class="bu">max</span>(prediction, <span class="dv">1</span>)[<span class="dv">1</span>].data.numpy()</span><span id="cb1-72"><a href="#cb1-72"></a><span class="bu">print</span>(pred_y, <span class="st">&#39;prediction number&#39;</span>)</span><span id="cb1-73"><a href="#cb1-73"></a><span class="bu">print</span>(test_y[:<span class="dv">20</span>], <span class="st">&#39;real number&#39;</span>)</span></code></pre></div><p>下面是训练结果的截图，可以看到效果还不错！</p><figure><img src="/images/ml/LSTM-MNIST.png" alt=""><figcaption>使用循环神经网络做手写数字识别</figcaption></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：本文为博主原创文章，转载请注明原文出处！&lt;/p&gt;
&lt;p&gt;写作时间：2019-03-02 21:36:12&lt;/p&gt;
&lt;h1 id=&quot;使用循环神经网络做手写数字识别&quot;&gt;使用循环神经网络做手写数字识别&lt;/h1&gt;
&lt;h2 id=&quot;思路分析&quot;&gt;思路分析&lt;/h2&gt;
&lt;p&gt;做图
      
    
    </summary>
    
      <category term="深度学习" scheme="http://theonegis.github.io/categories/dl/"/>
    
    
      <category term="PyTorch" scheme="http://theonegis.github.io/tags/PyTorch/"/>
    
      <category term="手写识别" scheme="http://theonegis.github.io/tags/%E6%89%8B%E5%86%99%E8%AF%86%E5%88%AB/"/>
    
      <category term="循环神经网络" scheme="http://theonegis.github.io/tags/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="RNN" scheme="http://theonegis.github.io/tags/RNN/"/>
    
  </entry>
  
</feed>
